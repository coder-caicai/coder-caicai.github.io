<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>菜菜的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="菜菜的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="菜菜的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="菜菜的博客">
<meta property="og:description" content="菜菜的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="菜菜的博客">
<meta name="twitter:description" content="菜菜的博客">
  
    <link rel="alternative" href="/atom.xml" title="菜菜的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">菜菜</a></h1>
		</hgroup>

		
		<p class="header-subtitle">菜菜的博客</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags">标签</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/memcached/" style="font-size: 10px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/soa/" style="font-size: 16.67px;">soa</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.didispace.com">程序猿DD</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">菜菜</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">菜菜</h1>
			</hgroup>
			
			<p class="header-subtitle">菜菜的博客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">标签</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-SpringBoot中使用JavaMailSender发送邮件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用JavaMailSender发送邮件/" class="article-date">
  	<time datetime="2016-06-15T09:39:06.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用JavaMailSender发送邮件/">SpringBoot中使用JavaMailSender发送邮件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用JavaMailSender发送邮件<br>2016年06月14日 标签：Spring Boot<br>相信使用过Spring的众多开发者都知道Spring提供了非常好用的JavaMailSender接口实现邮件发送。在Spring Boot的Starter模块中也为此提供了自动化配置。下面通过实例看看如何在Spring Boot中使用JavaMailSender发送邮件。</p>
<p>快速入门<br>在Spring Boot的工程中的pom.xml中引入spring-boot-starter-mail依赖：</p>
<pre><code>&lt;dependency&gt;  
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt; 

如其他自动化配置模块一样，在完成了依赖引入之后，只需要在application.properties中配置相应的属性内容。

下面我们以QQ邮箱为例，在application.properties中加入如下配置（注意替换自己的用户名和密码）：

spring.mail.host=smtp.qq.com  
spring.mail.username=用户名  
spring.mail.password=密码  
spring.mail.properties.mail.smtp.auth=true  
spring.mail.properties.mail.smtp.starttls.enable=true  
spring.mail.properties.mail.smtp.starttls.required=true  
通过单元测试来实现一封简单邮件的发送：

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
public class ApplicationTests {

    @Autowired
    private JavaMailSender mailSender;

    @Test
    public void sendSimpleMail() throws Exception {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(&quot;dyc87112@qq.com&quot;);
        message.setTo(&quot;dyc87112@qq.com&quot;);
        message.setSubject(&quot;主题：简单邮件&quot;);
        message.setText(&quot;测试邮件内容&quot;);

        mailSender.send(message);
    }

}
到这里，一个简单的邮件发送就完成了，运行一下该单元测试，看看效果如何？

由于Spring Boot的starter模块提供了自动化配置，所以在引入了spring-boot-starter-mail依赖之后，会根据配置文件中的内容去创建JavaMailSender实例，因此我们可以直接在需要使用的地方直接@Autowired来引入邮件发送对象。
进阶使用
在上例中，我们通过使用SimpleMailMessage实现了简单的邮件发送，但是实际使用过程中，我们还可能会带上附件、或是使用邮件模块等。这个时候我们就需要使用MimeMessage来设置复杂一些的邮件内容，下面我们就来依次实现一下。

发送附件
在上面单元测试中加入如下测试用例（通过MimeMessageHelper来发送一封带有附件的邮件）：

    @Test
    public void sendAttachmentsMail() throws Exception {

        MimeMessage mimeMessage = mailSender.createMimeMessage();

        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
        helper.setFrom(&quot;dyc87112@qq.com&quot;);
        helper.setTo(&quot;dyc87112@qq.com&quot;);
        helper.setSubject(&quot;主题：有附件&quot;);
        helper.setText(&quot;有附件的邮件&quot;);

        FileSystemResource file = new FileSystemResource(new File(&quot;weixin.jpg&quot;));
        helper.addAttachment(&quot;附件-1.jpg&quot;, file);
        helper.addAttachment(&quot;附件-2.jpg&quot;, file);

        mailSender.send(mimeMessage);

    }
嵌入静态资源
除了发送附件之外，我们在邮件内容中可能希望通过嵌入图片等静态资源，让邮件获得更好的阅读体验，而不是从附件中查看具体图片，下面的测试用例演示了如何通过MimeMessageHelper实现在邮件正文中嵌入静态资源。

    @Test
    public void sendInlineMail() throws Exception {

        MimeMessage mimeMessage = mailSender.createMimeMessage();

        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
        helper.setFrom(&quot;dyc87112@qq.com&quot;);
        helper.setTo(&quot;dyc87112@qq.com&quot;);
        helper.setSubject(&quot;主题：嵌入静态资源&quot;);
        helper.setText(&quot;&lt;html&gt;&lt;body&gt;&lt;img src=\&quot;cid:weixin\&quot; &gt;&lt;/body&gt;&lt;/html&gt;&quot;, true);

        FileSystemResource file = new FileSystemResource(new File(&quot;weixin.jpg&quot;));
        helper.addInline(&quot;weixin&quot;, file);

        mailSender.send(mimeMessage);

    }
这里需要注意的是addInline函数中资源名称weixin需要与正文中cid:weixin对应起来

模板邮件
通常我们使用邮件发送服务的时候，都会有一些固定的场景，比如重置密码、注册确认等，给每个用户发送的内容可能只有小部分是变化的。所以，很多时候我们会使用模板引擎来为各类邮件设置成模板，这样我们只需要在发送时去替换变化部分的参数即可。

在Spring Boot中使用模板引擎来实现模板化的邮件发送也是非常容易的，下面我们以velocity为例实现一下。

引入velocity模块的依赖：

&lt;dependency&gt;  
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-velocity&lt;/artifactId&gt;
&lt;/dependency&gt;  
在resources/templates/下，创建一个模板页面template.vm：

&lt;html&gt;  
&lt;body&gt;  
    &lt;h3&gt;你好， ${username}, 这是一封模板邮件!&lt;/h3&gt;
&lt;/body&gt;  
&lt;/html&gt;
</code></pre><p>我们之前在Spring Boot中开发Web应用时，提到过在Spring Boot的自动化配置下，模板默认位于resources/templates/目录下</p>
<p>最后，我们在单元测试中加入发送模板邮件的测试用例，具体如下：</p>
<pre><code>@Test
public void sendTemplateMail() throws Exception {

    MimeMessage mimeMessage = mailSender.createMimeMessage();

    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
    helper.setFrom(&quot;dyc87112@qq.com&quot;);
    helper.setTo(&quot;dyc87112@qq.com&quot;);
    helper.setSubject(&quot;主题：模板邮件&quot;);

    Map&lt;String, Object&gt; model = new HashedMap();
    model.put(&quot;username&quot;, &quot;didi&quot;);
    String text = VelocityEngineUtils.mergeTemplateIntoString(
            velocityEngine, &quot;template.vm&quot;, &quot;UTF-8&quot;, model);
    helper.setText(text, true);

    mailSender.send(mimeMessage);
}
</code></pre><p>尝试运行一下，就可以收到内容为你好， didi, 这是一封模板邮件!的邮件。这里，我们通过传入username的参数，在邮件内容中替换了模板中的${username}变量。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="spring-Cloud构建微服务架构（二）——服务消费者" class="article article-type-spring" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/Cloud构建微服务架构（二）——服务消费者/" class="article-date">
  	<time datetime="2016-06-15T09:38:31.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/Cloud构建微服务架构（二）——服务消费者/">Cloud构建微服务架构（二）——服务消费者</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringCloud构建微服务架构2——服务消费者" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringCloud构建微服务架构2——服务消费者/" class="article-date">
  	<time datetime="2016-06-15T09:37:37.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringCloud构建微服务架构2——服务消费者/">SpringCloud构建微服务架构2——服务消费者</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Cloud构建微服务架构（二）——服务消费者<br>2016年06月02日 标签：Spring Cloud, Spring Boot, Eureka, Netflix, Ribbon, Feign<br>在上一篇《Spring Cloud构建微服务架构（一）服务注册与发现》中，我们已经成功创建了“服务注册中心”，实现并注册了一个“服务提供者：COMPUTE-SERVICE”。那么我们要如何去消费服务提供者的接口内容呢？</p>
<p>Ribbon<br>Ribbon是一个基于HTTP和TCP客户端的负载均衡器。Feign中也使用Ribbon，后续会介绍Feign的使用。</p>
<p>Ribbon可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到均衡负载的作用。</p>
<p>当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务端列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。</p>
<p>下面我们通过实例看看如何使用Ribbon来调用服务，并实现客户端的均衡负载。</p>
<p>准备工作<br>启动Chapter-9-1-1中的服务注册中心：eureka-server<br>启动Chapter-9-1-1中的服务提供方：compute-service<br>修改compute-service中的server-port为2223，再启动一个服务提供方：compute-service<br>此时访问：<a href="http://localhost:1111/" target="_blank" rel="external">http://localhost:1111/</a></p>
<p>可以看到COMPUTE-SERVICE服务有两个单元正在运行：</p>
<p>192.168.21.101:compute-service:2222<br>192.168.21.101:compute-service:2223<br>使用Ribbon实现客户端负载均衡的消费者<br>构建一个基本Spring Boot项目，并在pom.xml中加入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; </span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;  </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;  </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;Brixton.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></p>
<p>在应用主类中，通过@EnableDiscoveryClient注解来添加发现服务能力。创建RestTemplate实例，并通过@LoadBalanced注解开启均衡负载能力。</p>
<p>@SpringBootApplication<br>@EnableDiscoveryClient<br>public class RibbonApplication {</p>
<pre><code>@Bean
@LoadBalanced
RestTemplate restTemplate() {
    return new RestTemplate();
}

public static void main(String[] args) {
    SpringApplication.run(RibbonApplication.class, args);
}
</code></pre><p>}<br>创建ConsumerController来消费COMPUTE-SERVICE的add服务。通过直接RestTemplate来调用服务，计算10 + 20的值。</p>
<p>@RestController<br>public class ConsumerController {</p>
<pre><code>@Autowired
RestTemplate restTemplate;

@RequestMapping(value = &quot;/add&quot;, method = RequestMethod.GET)
public String add() {
    return restTemplate.getForEntity(&quot;http://COMPUTE-SERVICE/add?a=10&amp;b=20&quot;, String.class).getBody();
}
</code></pre><p>}<br>application.properties中配置eureka服务注册中心</p>
<p>spring.application.name=ribbon-consumer<br>server.port=3333</p>
<p>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1111/eureka/" target="_blank" rel="external">http://localhost:1111/eureka/</a><br>启动该应用，并访问两次：<a href="http://localhost:3333/add" target="_blank" rel="external">http://localhost:3333/add</a></p>
<p>然后，打开compute-service的两个服务提供方，分别输出了类似下面的日志内容：</p>
<p>端口为2222服务提供端的日志：<br>2016-06-02 11:16:26.787  INFO 90014 — [io-2222-exec-10] com.didispace.web.ComputeController      : /add, host:192.168.21.101, service_id:compute-service, result:30<br>端口为2223服务提供端的日志：<br>2016-06-02 11:19:41.241  INFO 90122 — [nio-2223-exec-1] com.didispace.web.ComputeController      : /add, host:192.168.21.101, service_id:compute-service, result:30<br>可以看到，之前启动的两个compute-service服务端分别被调用了一次。到这里，我们已经通过Ribbon在客户端已经实现了对服务调用的均衡负载。</p>
<p>完整示例可参考：Chapter9-1-2/eureka-ribbon</p>
<p>Feign<br>Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它既可完成。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。Feign也支持可插拔的编码器和解码器。Spring Cloud为Feign增加了对Spring MVC注解的支持，还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p>
<p>下面，通过一个例子来展现Feign如何方便的声明对上述computer-service服务的定义和调用。</p>
<p>创建一个Spring Boot工程，配置pom.xml，将上述的配置中的ribbon依赖替换成feign的依赖即可，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;  </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;  </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;Brixton.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<p>在应用主类中通过@EnableFeignClients注解开启Feign功能，具体如下：</p>
<p>@SpringBootApplication<br>@EnableDiscoveryClient<br>@EnableFeignClients<br>public class FeignApplication {</p>
<pre><code>public static void main(String[] args) {
    SpringApplication.run(FeignApplication.class, args);
}
</code></pre><p>}<br>定义compute-service服务的接口，具体如下：</p>
<p>@FeignClient(“compute-service”)<br>public interface ComputeClient {</p>
<pre><code>@RequestMapping(method = RequestMethod.GET, value = &quot;/add&quot;)
Integer add(@RequestParam(value = &quot;a&quot;) Integer a, @RequestParam(value = &quot;b&quot;) Integer b);
</code></pre><p>}<br>使用@FeignClient(“compute-service”)注解来绑定该接口对应compute-service服务<br>通过Spring MVC的注解来配置compute-service服务下的具体实现。<br>在web层中调用上面定义的ComputeClient，具体如下：</p>
<p>@RestController<br>public class ConsumerController {</p>
<pre><code>@Autowired
ComputeClient computeClient;

@RequestMapping(value = &quot;/add&quot;, method = RequestMethod.GET)
public Integer add() {
    return computeClient.add(10, 20);
}
</code></pre><p>}<br>application.properties中不用变，指定eureka服务注册中心即可，如：</p>
<p>spring.application.name=feign-consumer<br>server.port=3333</p>
<p>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1111/eureka/" target="_blank" rel="external">http://localhost:1111/eureka/</a><br>启动该应用，访问几次：<a href="http://localhost:3333/add" target="_blank" rel="external">http://localhost:3333/add</a></p>
<p>再观察日志，可以得到之前使用Ribbon时一样的结果，对服务提供方实现了均衡负载。</p>
<p>这一节我们通过Feign以接口和注解配置的方式，轻松实现了对compute-service服务的绑定，这样我们就可以在本地应用中像本地服务一下的调用它，并且做到了客户端均衡负载。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringCloud构建微服务架构1——服务注册与发现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringCloud构建微服务架构1——服务注册与发现/" class="article-date">
  	<time datetime="2016-06-15T09:34:53.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringCloud构建微服务架构1——服务注册与发现/">SpringCloud构建微服务架构1——服务注册与发现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Cloud构建微服务架构（一）——服务注册与发现<br>2016年05月31日 标签：Spring Cloud, Spring Boot, Netflix, Eureka<br>Spring Cloud简介<br>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</p>
<p>微服务架构<br>“微服务架构”在这几年非常的火热，以至于关于微服务架构相关的产品社区也变得越来越活跃（比如：netflix、dubbo），Spring Cloud也因Spring社区的强大知名度和影响力也被广大架构师与开发者备受关注。</p>
<p>那么什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p>
<p>对于“微服务架构”，大家在互联网可以搜索到很多相关的介绍和研究文章来进行学习和了解。也可以阅读始祖Martin Fowler的《Microservices》，本文不做更多的介绍和描述。</p>
<p>服务注册与发现<br>在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud搭建服务注册与发现模块。</p>
<p>这里我们会用到Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。</p>
<p>所以，我们这里的核心内容就是服务发现模块：Eureka。下面我们动手来做一些尝试。</p>
<p>创建“服务注册中心”<br>创建一个基础的Spring Boot工程，并在pom.xml中引入需要的依赖内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;  </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;  </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;Brixton.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：</p>
<p>@EnableEurekaServer<br>@SpringBootApplication<br>public class Application {</p>
<pre><code>public static void main(String[] args) {
    new SpringApplicationBuilder(Application.class).web(true).run(args);
}
</code></pre><p>}<br>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties中问增加如下配置：</p>
<p>server.port=1111</p>
<p>eureka.client.register-with-eureka=false<br>eureka.client.fetch-registry=false<br>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:${server.port}/eureka/" target="_blank" rel="external">http://localhost:${server.port}/eureka/</a><br>为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1111。</p>
<p>启动工程后，访问：<a href="http://localhost:1111/" target="_blank" rel="external">http://localhost:1111/</a></p>
<p>可以看到下面的页面，其中还没有发现任何服务</p>
<p>alt</p>
<p>该工程可参见：Chapter9-1-1/eureka-server</p>
<p>创建“服务提供方”<br>下面我们创建提供服务的客户端，并向服务注册中心注册自己。</p>
<p>假设我们有一个提供计算功能的微服务模块，我们实现一个RESTful API，通过传入两个参数a和b，最后返回a + b的结果。</p>
<p>首先，创建一个基本的Spring Boot应用，在pom.xml中，加入如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;  </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;  </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;Brixton.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></p>
<p>其次，实现/add请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。</p>
<p>@RestController<br>public class ComputeController {</p>
<pre><code>private final Logger logger = Logger.getLogger(getClass());

@Autowired
private DiscoveryClient client;

@RequestMapping(value = &quot;/add&quot; ,method = RequestMethod.GET)
public Integer add(@RequestParam Integer a, @RequestParam Integer b) {
    ServiceInstance instance = client.getLocalServiceInstance();
    Integer r = a + b;
    logger.info(&quot;/add, host:&quot; + instance.getHost() + &quot;, service_id:&quot; + instance.getServiceId() + &quot;, result:&quot; + r);
    return r;
}
</code></pre><p>}<br>最后在主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，才能实现Controller中对服务信息的输出。</p>
<p>@EnableDiscoveryClient<br>@SpringBootApplication<br>public class ComputeServiceApplication {</p>
<pre><code>public static void main(String[] args) {
    new SpringApplicationBuilder(ComputeServiceApplication.class).web(true).run(args);
}
</code></pre><p>}<br>我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：</p>
<p>spring.application.name=compute-service</p>
<p>server.port=2222</p>
<p>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1111/eureka/" target="_blank" rel="external">http://localhost:1111/eureka/</a><br>通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。</p>
<p>eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。</p>
<p>为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。</p>
<p>启动该工程后，再次访问：<a href="http://localhost:1111/" target="_blank" rel="external">http://localhost:1111/</a></p>
<p>可以看到，我们定义的服务被注册了。</p>
<p><img src="http://blog.didispace.com/content/images/2016/05/QQ--20160531221940.png"></p>
<p>该工程可参见：Chapter9-1-1/compute-service</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中的事务管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中的事务管理/" class="article-date">
  	<time datetime="2016-06-15T09:33:05.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中的事务管理/">SpringBoot中的事务管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中的事务管理<br>2016年05月27日 标签：Spring Boot, 事务, Transactional<br>什么是事务？<br>我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。</p>
<p>事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。</p>
<p>事务管理是Spring框架中最为常用的功能之一，我们在使用Spring Boot开发应用时，大部分情况下也都需要使用事务。</p>
<p>快速入门<br>在Spring Boot中，当我们使用了spring-boot-starter-jdbc或spring-boot-starter-data-jpa依赖的时候，框架会自动默认分别注入DataSourceTransactionManager或JpaTransactionManager。所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。</p>
<p>我们以之前实现的《用spring-data-jpa访问数据库》的示例Chapter3-2-2作为基础工程进行事务的使用常识。</p>
<p>在该样例工程中（若对该数据访问方式不了解，可先阅读该文章），我们引入了spring-data-jpa，并创建了User实体以及对User的数据访问对象UserRepository，在ApplicationTest类中实现了使用UserRepository进行数据读写的单元测试用例，如下：</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private UserRepository userRepository;

@Test
public void test() throws Exception {

    // 创建10条记录
    userRepository.save(new User(&quot;AAA&quot;, 10));
    userRepository.save(new User(&quot;BBB&quot;, 20));
    userRepository.save(new User(&quot;CCC&quot;, 30));
    userRepository.save(new User(&quot;DDD&quot;, 40));
    userRepository.save(new User(&quot;EEE&quot;, 50));
    userRepository.save(new User(&quot;FFF&quot;, 60));
    userRepository.save(new User(&quot;GGG&quot;, 70));
    userRepository.save(new User(&quot;HHH&quot;, 80));
    userRepository.save(new User(&quot;III&quot;, 90));
    userRepository.save(new User(&quot;JJJ&quot;, 100));

    // 省略后续的一些验证操作
}
</code></pre><p>}<br>可以看到，在这个单元测试用例中，使用UserRepository对象连续创建了10个User实体到数据库中，下面我们人为的来制造一些异常，看看会发生什么情况。</p>
<p>通过定义User的name属性长度为5，这样通过创建时User实体的name属性超长就可以触发异常产生。</p>
<p>@Entity<br>public class User {</p>
<pre><code>@Id
@GeneratedValue
private Long id;

@Column(nullable = false, length = 5)
private String name;

@Column(nullable = false)
private Integer age;

// 省略构造函数、getter和setter
</code></pre><p>}<br>修改测试用例中创建记录的语句，将一条记录的name长度超过5，如下：name为HHHHHHHHH的User对象将会抛出异常。</p>
<p>// 创建10条记录<br>userRepository.save(new User(“AAA”, 10));<br>userRepository.save(new User(“BBB”, 20));<br>userRepository.save(new User(“CCC”, 30));<br>userRepository.save(new User(“DDD”, 40));<br>userRepository.save(new User(“EEE”, 50));<br>userRepository.save(new User(“FFF”, 60));<br>userRepository.save(new User(“GGG”, 70));<br>userRepository.save(new User(“HHHHHHHHHH”, 80));<br>userRepository.save(new User(“III”, 90));<br>userRepository.save(new User(“JJJ”, 100));<br>执行测试用例，可以看到控制台中抛出了如下异常，name字段超长：</p>
<p>2016-05-27 10:30:35.948  WARN 2660 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1406, SQLState: 22001<br>2016-05-27 10:30:35.948 ERROR 2660 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data truncation: Data too long for column ‘name’ at row 1<br>2016-05-27 10:30:35.951  WARN 2660 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Warning Code: 1406, SQLState: HY000<br>2016-05-27 10:30:35.951  WARN 2660 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data too long for column ‘name’ at row 1</p>
<p>org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.DataException: could not execute statement<br>此时查数据库中，创建了name从AAA到GGG的记录，没有HHHHHHHHHH、III、JJJ的记录。而若这是一个希望保证完整性操作的情况下，AAA到GGG的记录希望能在发生异常的时候被回退，这时候就可以使用事务让它实现回退，做法非常简单，我们只需要在test函数上添加@Transactional注解即可。</p>
<p>@Test<br>@Transactional<br>public void test() throws Exception {</p>
<pre><code>// 省略测试内容
</code></pre><p>}<br>再来执行该测试用例，可以看到控制台中输出了回滚日志（Rolled back transaction for test context），</p>
<p>2016-05-27 10:35:32.210  WARN 5672 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1406, SQLState: 22001<br>2016-05-27 10:35:32.210 ERROR 5672 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data truncation: Data too long for column ‘name’ at row 1<br>2016-05-27 10:35:32.213  WARN 5672 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Warning Code: 1406, SQLState: HY000<br>2016-05-27 10:35:32.213  WARN 5672 — [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data too long for column ‘name’ at row 1<br>2016-05-27 10:35:32.221  INFO 5672 — [           main] o.s.t.c.transaction.TransactionContext   : Rolled back transaction for test context [DefaultTestContext@1d7a715 testClass = ApplicationTests, testInstance = com.didispace.ApplicationTests@95a785, testMethod = test@ApplicationTests, testException = org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.DataException: could not execute statement, mergedContextConfiguration = [MergedContextConfiguration@11f39f9 testClass = ApplicationTests, locations = ‘{}’, classes = ‘{class com.didispace.Application}’, contextInitializerClasses = ‘[]’, activeProfiles = ‘{}’, propertySourceLocations = ‘{}’, propertySourceProperties = ‘{}’, contextLoader = ‘org.springframework.boot.test.SpringApplicationContextLoader’, parent = [null]]].</p>
<p>org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.DataException: could not execute statement<br>再看数据库中，User表就没有AAA到GGG的用户数据了，成功实现了自动回滚。</p>
<p>这里主要通过单元测试演示了如何使用@Transactional注解来声明一个函数需要被事务管理，通常我们单元测试为了保证每个测试之间的数据独立，会使用@Rollback注解让每个单元测试都能在结束时回滚。而真正在开发业务逻辑时，我们通常在service层接口中使用@Transactional来对各个业务逻辑进行事务管理的配置，例如：</p>
<p>public interface UserService {</p>
<pre><code>@Transactional
User login(String name, String password);
</code></pre><p>}<br>事务详解<br>上面的例子中我们使用了默认的事务配置，可以满足一些基本的事务需求，但是当我们项目较大较复杂时（比如，有多个数据源等），这时候需要在声明事务时，指定不同的事务管理器。对于不同数据源的事务管理配置可以见《Spring Boot多数据源配置与使用》中的设置。在声明事务时，只需要通过value属性指定配置的事务管理器名即可，例如：@Transactional(value=”transactionManagerPrimary”)。</p>
<p>除了指定不同的事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释：</p>
<p>　隔离级别<br>隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读。</p>
<p>我们可以看org.springframework.transaction.annotation.Isolation枚举类中定义了五个表示隔离级别的值：</p>
<p>public enum Isolation {<br>    DEFAULT(-1),<br>    READ_UNCOMMITTED(1),<br>    READ_COMMITTED(2),<br>    REPEATABLE_READ(4),<br>    SERIALIZABLE(8);<br>}<br>DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。<br>READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。<br>READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。<br>REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。<br>SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。<br>指定方法：通过使用isolation属性设置，例如：</p>
<p>@Transactional(isolation = Isolation.DEFAULT)<br>传播行为<br>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。</p>
<p>我们可以看org.springframework.transaction.annotation.Propagation枚举类中定义了6个表示传播行为的枚举值：</p>
<p>public enum Propagation {<br>    REQUIRED(0),<br>    SUPPORTS(1),<br>    MANDATORY(2),<br>    REQUIRES_NEW(3),<br>    NOT_SUPPORTED(4),<br>    NEVER(5),<br>    NESTED(6);<br>}<br>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。<br>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。<br>NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。<br>指定方法：通过使用propagation属性设置，例如：</p>
<p>@Transactional(propagation = Propagation.REQUIRED)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用log4j实现http请求日志入mongodb" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用log4j实现http请求日志入mongodb/" class="article-date">
  	<time datetime="2016-06-15T09:31:55.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用log4j实现http请求日志入mongodb/">SpringBoot中使用log4j实现http请求日志入mongodb</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用log4j实现http请求日志入mongodb<br>2016年05月25日 标签：Spring Boot, mongodb, log4j<br>之前在《使用AOP统一处理Web请求日志》一文中介绍了如何使用AOP统一记录web请求日志。基本思路是通过aop去切web层的controller实现，获取每个http的内容并通过log4j将日志内容写到应用服务器的文件系统中。</p>
<p>但是当我们在集群中部署应用之后，应用请求的日志被分散记录在了不同应用服务器的文件系统上，这样分散的存储并不利于我们对日志内容的检索。解决日志分散问题的方案多种多样，本文思路以在《使用AOP统一处理Web请求日志》一文的基础之上，扩展log4j实现将日志写入MongoDB。</p>
<p>准备工作<br>可以先拿Chapter4-2-4工程为基础，进行后续的实验改造。该工程实现了一个简单的REST接口，一个对web层的切面，并在web层切面前后记录http请求的日志内容。</p>
<p>通过自定义appender实现<br>思路：log4j提供的输出器实现自Appender接口，要自定义appender输出到MongoDB，只需要继承AppenderSkeleton类，并实现几个方法即可完成。</p>
<p>引入mongodb的驱动<br>在pom.xml中引入下面依赖</p>
<p><dependency><br>    <groupid>org.mongodb</groupid><br>    <artifactid>mongodb-driver</artifactid><br>    <version>3.2.2</version><br></dependency><br>实现MongoAppender<br>编写MongoAppender类继承AppenderSkeleton，实现如下：</p>
<p>public class MongoAppender  extends AppenderSkeleton {</p>
<pre><code>private MongoClient mongoClient;
private MongoDatabase mongoDatabase;
private MongoCollection&lt;BasicDBObject&gt; logsCollection;

private String connectionUrl;
private String databaseName;
private String collectionName;

@Override
protected void append(LoggingEvent loggingEvent) {

    if(mongoDatabase == null) {
        MongoClientURI connectionString = new MongoClientURI(connectionUrl);
        mongoClient = new MongoClient(connectionString);
        mongoDatabase = mongoClient.getDatabase(databaseName);
        logsCollection = mongoDatabase.getCollection(collectionName, BasicDBObject.class);
    }
    logsCollection.insertOne((BasicDBObject) loggingEvent.getMessage());

}

@Override
public void close() {
    if(mongoClient != null) {
        mongoClient.close();
    }
}

@Override
public boolean requiresLayout() {
    return false;
}

// 省略getter和setter
</code></pre><p>}<br>定义MongoDB的配置参数，可通过log4j.properties配置：</p>
<p>connectionUrl：连接mongodb的串<br>databaseName：数据库名<br>collectionName：集合名<br>定义MongoDB的连接和操作对象，根据log4j.properties配置的参数初始化：</p>
<p>mongoClient：mongodb的连接客户端<br>mongoDatabase：记录日志的数据库<br>logsCollection：记录日志的集合<br>重写append函数：</p>
<p>根据log4j.properties中的配置创建mongodb连接<br>LoggingEvent提供getMessage()函数来获取日志消息<br>往配置的记录日志的collection中插入日志消息<br>重写close函数：关闭mongodb的</p>
<p>配置log4j.properties<br>设置名为mongodb的logger：</p>
<p>记录INFO级别日志<br>appender实现为com.didispace.log.MongoAppende<br>mongodb连接地址：mongodb://localhost:27017<br>mongodb数据库名：logs<br>mongodb集合名：logs_request<br>log4j.logger.mongodb=INFO, mongodb  </p>
<h1 id="mongodb输出"><a href="#mongodb输出" class="headerlink" title="mongodb输出"></a>mongodb输出</h1><p>log4j.appender.mongodb=com.didispace.log.MongoAppender<br>log4j.appender.mongodb.connectionUrl=mongodb://localhost:27017<br>log4j.appender.mongodb.databaseName=logs<br>log4j.appender.mongodb.collectionName=logs_request<br>切面中使用mongodb logger<br>修改后的代码如下，主要做了以下几点修改：</p>
<p>logger取名为mongodb的<br>通过getBasicDBObject函数从HttpServletRequest和JoinPoint对象中获取请求信息，并组装成BasicDBObject<br>getHeadersInfo函数从HttpServletRequest中获取header信息<br>通过logger.info()，输出BasicDBObject对象的信息到mongodb<br>@Aspect<br>@Order(1)<br>@Component<br>public class WebLogAspect {</p>
<pre><code>private Logger logger = Logger.getLogger(&quot;mongodb&quot;);

@Pointcut(&quot;execution(public * com.didispace.web..*.*(..))&quot;)
public void webLog(){}

@Before(&quot;webLog()&quot;)
public void doBefore(JoinPoint joinPoint) throws Throwable {
    // 获取HttpServletRequest
    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
    HttpServletRequest request = attributes.getRequest();
    // 获取要记录的日志内容
    BasicDBObject logInfo = getBasicDBObject(request, joinPoint);
    logger.info(logInfo);
}


private BasicDBObject getBasicDBObject(HttpServletRequest request, JoinPoint joinPoint) {
    // 基本信息
    BasicDBObject r = new BasicDBObject();
    r.append(&quot;requestURL&quot;, request.getRequestURL().toString());
    r.append(&quot;requestURI&quot;, request.getRequestURI());
    r.append(&quot;queryString&quot;, request.getQueryString());
    r.append(&quot;remoteAddr&quot;, request.getRemoteAddr());
    r.append(&quot;remoteHost&quot;, request.getRemoteHost());
    r.append(&quot;remotePort&quot;, request.getRemotePort());
    r.append(&quot;localAddr&quot;, request.getLocalAddr());
    r.append(&quot;localName&quot;, request.getLocalName());
    r.append(&quot;method&quot;, request.getMethod());
    r.append(&quot;headers&quot;, getHeadersInfo(request));
    r.append(&quot;parameters&quot;, request.getParameterMap());
    r.append(&quot;classMethod&quot;, joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());
    r.append(&quot;args&quot;, Arrays.toString(joinPoint.getArgs()));
    return r;
}

private Map&lt;String, String&gt; getHeadersInfo(HttpServletRequest request) {
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    Enumeration headerNames = request.getHeaderNames();
    while (headerNames.hasMoreElements()) {
        String key = (String) headerNames.nextElement();
        String value = request.getHeader(key);
        map.put(key, value);
    }
    return map;
}
</code></pre><p>}<br>完整示例：Chapter4-2-5</p>
<p>其他补充<br>上述内容主要提供一个思路去实现自定义日志的输出和管理。我们可以通过jdbc实现日志记录到mongodb，也可以通过spring-data-mongo来记录到mongodb，当然我们也可以输出到其他数据库，或者输出到消息队列等待其他后续处理等。</p>
<p>对于日志记录到mongodb，也可以直接使用log4mongo实现更为方便快捷。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用AOP统一处理Web请求日志" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用AOP统一处理Web请求日志/" class="article-date">
  	<time datetime="2016-06-15T09:30:47.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用AOP统一处理Web请求日志/">SpringBoot中使用AOP统一处理Web请求日志</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用AOP统一处理Web请求日志<br>2016年05月20日 标签：Spring Boot<br>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是Spring框架中的一个重要内容，它通过对既有程序定义一个切入点，然后在其前后切入不同的执行内容，比如常见的有：打开数据库连接/关闭数据库连接、打开事务/关闭事务、记录日志等。基于AOP不会破坏原来程序逻辑，因此它可以很好的对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p>下面主要讲两个内容，一个是如何在Spring Boot中引入Aop功能，二是如何使用Aop做切面去统一处理Web请求的日志。</p>
<p>以下所有操作基于chapter4-2-2工程进行。</p>
<p>准备工作<br>因为需要对web请求做切面来记录日志，所以先引入web模块，并创建一个简单的hello请求的处理。</p>
<p>pom.xml中引入web模块</p>
<p><dependency><br>    <groupid>org.springframework.boot</groupid><br>    <artifactid>spring-boot-starter-web</artifactid><br></dependency><br>实现一个简单请求处理：通过传入name参数，返回“hello xxx”的功能。<br>@RestController<br>public class HelloController {</p>
<pre><code>@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
@ResponseBody
public String hello(@RequestParam String name) {
    return &quot;Hello &quot; + name;
}
</code></pre><p>}<br>下面，我们可以对上面的/hello请求，进行切面日志记录。</p>
<p>引入AOP依赖<br>在Spring Boot中引入AOP就跟引入其他模块一样，非常简单，只需要在pom.xml中加入如下依赖：</p>
<p><dependency><br>    <groupid>org.springframework.boot</groupid><br>    <artifactid>spring-boot-starter-aop</artifactid><br></dependency><br>在完成了引入AOP依赖包后，一般来说并不需要去做其他配置。也许在Spring中使用过注解配置方式的人会问是否需要在程序主类中增加@EnableAspectJAutoProxy来启用，实际并不需要。</p>
<p>可以看下面关于AOP的默认配置属性，其中spring.aop.auto属性默认是开启的，也就是说只要引入了AOP依赖后，默认已经增加了@EnableAspectJAutoProxy。</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>spring.aop.auto=true # Add @EnableAspectJAutoProxy.<br>spring.aop.proxy-target-class=false # Whether subclass-based (CGLIB) proxies are to be created (true) as<br> opposed to standard Java interface-based proxies (false).<br>而当我们需要使用CGLIB来实现AOP的时候，需要配置spring.aop.proxy-target-class=true，不然默认使用的是标准Java的实现。</p>
<p>实现Web层的日志切面<br>实现AOP的切面主要有以下几个要素：</p>
<p>使用@Aspect注解将一个java类定义为切面类<br>使用@Pointcut定义一个切入点，可以是一个规则表达式，比如下例中某个package下的所有函数，也可以是一个注解等。<br>根据需要在切入点不同位置的切入内容<br>使用@Before在切入点开始处切入内容<br>使用@After在切入点结尾处切入内容<br>使用@AfterReturning在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）<br>使用@Around在切入点前后切入内容，并自己控制何时执行切入点自身的内容<br>使用@AfterThrowing用来处理当切入内容部分抛出异常之后的处理逻辑<br>@Aspect<br>@Component<br>public class WebLogAspect {</p>
<pre><code>private Logger logger = Logger.getLogger(getClass());

@Pointcut(&quot;execution(public * com.didispace.web..*.*(..))&quot;)
public void webLog(){}

@Before(&quot;webLog()&quot;)
public void doBefore(JoinPoint joinPoint) throws Throwable {
    // 接收到请求，记录请求内容
    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
    HttpServletRequest request = attributes.getRequest();

    // 记录下请求内容
    logger.info(&quot;URL : &quot; + request.getRequestURL().toString());
    logger.info(&quot;HTTP_METHOD : &quot; + request.getMethod());
    logger.info(&quot;IP : &quot; + request.getRemoteAddr());
    logger.info(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());
    logger.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));

}

@AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)
public void doAfterReturning(Object ret) throws Throwable {
    // 处理完请求，返回内容
    logger.info(&quot;RESPONSE : &quot; + ret);
}
</code></pre><p>}<br>可以看上面的例子，通过@Pointcut定义的切入点为com.didispace.web包下的所有函数（对web层所有请求处理做切入点），然后通过@Before实现，对请求内容的日志记录（本文只是说明过程，可以根据需要调整内容），最后通过@AfterReturning记录请求返回的对象。</p>
<p>通过运行程序并访问：<a href="http://localhost:8080/hello?name=didi，可以获得下面的日志输出" target="_blank" rel="external">http://localhost:8080/hello?name=didi，可以获得下面的日志输出</a></p>
<p>2016-05-19 13:42:13,156  INFO WebLogAspect:41 - URL : <a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a><br>2016-05-19 13:42:13,156  INFO WebLogAspect:42 - HTTP_METHOD : <a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a><br>2016-05-19 13:42:13,157  INFO WebLogAspect:43 - IP : 0:0:0:0:0:0:0:1<br>2016-05-19 13:42:13,160  INFO WebLogAspect:44 - CLASS_METHOD : com.didispace.web.HelloController.hello<br>2016-05-19 13:42:13,160  INFO WebLogAspect:45 - ARGS : [didi]<br>2016-05-19 13:42:13,170  INFO WebLogAspect:52 - RESPONSE:Hello didi<br>优化：AOP切面中的同步问题<br>在WebLogAspect切面中，分别通过doBefore和doAfterReturning两个独立函数实现了切点头部和切点返回后执行的内容，若我们想统计请求的处理时间，就需要在doBefore处记录时间，并在doAfterReturning处通过当前时间与开始处记录的时间计算得到请求处理的消耗时间。</p>
<p>那么我们是否可以在WebLogAspect切面中定义一个成员变量来给doBefore和doAfterReturning一起访问呢？是否会有同步问题呢？</p>
<p>的确，直接在这里定义基本类型会有同步问题，所以我们可以引入ThreadLocal对象，像下面这样进行记录：</p>
<p>@Aspect<br>@Component<br>public class WebLogAspect {</p>
<pre><code>private Logger logger = Logger.getLogger(getClass());

ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;&gt;();

@Pointcut(&quot;execution(public * com.didispace.web..*.*(..))&quot;)
public void webLog(){}

@Before(&quot;webLog()&quot;)
public void doBefore(JoinPoint joinPoint) throws Throwable {
    startTime.set(System.currentTimeMillis());

    // 省略日志记录内容
}

@AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)
public void doAfterReturning(Object ret) throws Throwable {
    // 处理完请求，返回内容
    logger.info(&quot;RESPONSE : &quot; + ret);
    logger.info(&quot;SPEND TIME : &quot; + (System.currentTimeMillis() - startTime.get()));
}
</code></pre><p>}<br>优化：AOP切面的优先级<br>由于通过AOP实现，程序得到了很好的解耦，但是也会带来一些问题，比如：我们可能会对Web层做多个切面，校验用户，校验头信息等等，这个时候经常会碰到切面的处理顺序问题。</p>
<p>所以，我们需要定义每个切面的优先级，我们需要@Order(i)注解来标识切面的优先级。i的值越小，优先级越高。假设我们还有一个切面是CheckNameAspect用来校验name必须为didi，我们为其设置@Order(10)，而上文中WebLogAspect设置为@Order(5)，所以WebLogAspect有更高的优先级，这个时候执行顺序是这样的：</p>
<p>在@Before中优先执行@Order(5)的内容，再执行@Order(10)的内容<br>在@After和@AfterReturning中优先执行@Order(10)的内容，再执行@Order(5)的内容<br>所以我们可以这样子总结：</p>
<p>在切入点前的操作，按order的值由小到大执行<br>在切入点后的操作，按order的值由大到小执行<br>本文完整示例Chapter4-2-4</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中对log4j进行多环境不同日志级别的控制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中对log4j进行多环境不同日志级别的控制/" class="article-date">
  	<time datetime="2016-06-15T09:29:54.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中对log4j进行多环境不同日志级别的控制/">SpringBoot中对log4j进行多环境不同日志级别的控制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中对log4j进行多环境不同日志级别的控制<br>2016年05月19日 标签：Spring Boot<br>之前介绍了在《Spring boot中使用log4j记录日志》，仅通过log4j.properties对日志级别进行控制，对于需要多环境部署的环境不是很方便，可能我们在开发环境大部分模块需要采用DEBUG级别，在测试环境可能需要小部分采用DEBUG级别，而在生产环境时我们又希望采用INFO级别。这个时候，我们要自己手工编辑log4j.properties文件来调整日志级别，不论在版本库中默认保存哪个环境的级别设定，都会增加其他环境使用人员的工作量，虽然很细微，但是手工修改总不是一件很好的选择，难免会发现修改后误提交等问题。</p>
<p>那么，有没有办法对于开发人员、运维人员都不需要改变源代码实现不同环境的不同日志级别呢?</p>
<p>是否还记得之前在《Spring Boot属性配置文件详解》一文中，提到的关于Spring Boot多环境的配置以及属性文件中的参数引用？若没有了解过相关内容，建议先阅读该文后继续此篇内容。</p>
<p>尝试改造<br>先以chapter4-2-2工程作为基础工程，我们来进行多环境配置的改造。</p>
<p>创建多环境配置文件<br>application-dev.properties：开发环境<br>application-test.properties：测试环境<br>application-prod.properties：生产环境<br>application.properties中添加属性：spring.profiles.active=dev（默认激活application-dev.properties配置）<br>application-dev.properties和application-test.properties配置文件中添加日志级别定义：logging.level.com.didispace=DEBUG<br>application-prod.properties配置文件中添加日志级别定义：logging.level.com.didispace=INFO<br>通过上面的定义，根据logging.level.com.didispace在不同环境的配置文件中定义了不同的级别，但是我们已经把日志交给了log4j管理，看看我们log4j.properties中对com.didispace包下的日志定义是这样的，固定定义了DEBUG级别，并输出到名为didifile定义的appender中。</p>
<h1 id="LOG4J配置"><a href="#LOG4J配置" class="headerlink" title="LOG4J配置"></a>LOG4J配置</h1><p>log4j.category.com.didispace=DEBUG, didifile</p>
<h1 id="com-didispace下的日志输出"><a href="#com-didispace下的日志输出" class="headerlink" title="com.didispace下的日志输出"></a>com.didispace下的日志输出</h1><p>log4j.appender.didifile=org.apache.log4j.DailyRollingFileAppender<br>log4j.appender.didifile.file=logs/my.log<br>log4j.appender.didifile.DatePattern=’.’yyyy-MM-dd<br>log4j.appender.didifile.layout=org.apache.log4j.PatternLayout<br>log4j.appender.didifile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L —- %m%n<br>那么，要如何动态的改变这个DEBUG级别呢？在《Spring Boot属性配置文件详解》中还提到了关于配置文件中参数的引用。我们需要将DEBUG替换成application-{profile}.properties配置文件中定义logging.level.com.didispace即可，所以配置变为如下内容：</p>
<h1 id="LOG4J配置-1"><a href="#LOG4J配置-1" class="headerlink" title="LOG4J配置"></a>LOG4J配置</h1><p>log4j.category.com.didispace=${logging.level.com.didispace}, didifile</p>
<h1 id="com-didispace下的日志输出-1"><a href="#com-didispace下的日志输出-1" class="headerlink" title="com.didispace下的日志输出"></a>com.didispace下的日志输出</h1><p>log4j.appender.didifile=org.apache.log4j.DailyRollingFileAppender<br>log4j.appender.didifile.file=logs/my.log<br>log4j.appender.didifile.DatePattern=’.’yyyy-MM-dd<br>log4j.appender.didifile.layout=org.apache.log4j.PatternLayout<br>log4j.appender.didifile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L —- %m%n<br>到这里我们已经完成了所有配置工作，我们可以通过运行单元测试，然后看my.log文件中输出的日志内容。通过修改默认的application-dev.properties配置的日志级别为INFO，再运行单元测试的DEBUG内容是否被输出到了my.log中验证参数是否被正确引用了。</p>
<p>对于不同环境的使用人员也不需要改变代码或打包文件，只需要通过执行命令中参加参数即可，比如我想采用生产环境的级别，那么我可以这样运行应用：</p>
<p>java -jar xxx.jar –spring.profiles.active=prod</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Springboot中使用log4j记录日志" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/Springboot中使用log4j记录日志/" class="article-date">
  	<time datetime="2016-06-15T09:29:08.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/Springboot中使用log4j记录日志/">Springboot中使用log4j记录日志</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring boot中使用log4j记录日志<br>2016年05月19日 标签：Spring Boot<br>之前在Spring Boot日志管理 一文中主要介绍了Spring Boot中默认日志工具（logback）的基本配置内容。对于很多习惯使用log4j的开发者，Spring Boot依然可以很好的支持，只是需要做一些小小的配置功能。</p>
<p>引入log4j依赖<br>在创建Spring Boot工程时，我们引入了spring-boot-starter，其中包含了spring-boot-starter-logging，该依赖内容就是Spring Boot默认的日志框架Logback，所以我们在引入log4j之前，需要先排除该包的依赖，再引入log4j的依赖，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt; </span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>配置log4j.properties<br>在引入了log4j依赖之后，只需要在src/main/resources目录下加入log4j.properties配置文件，就可以开始对应用的日志进行配置使用。</p>
<p>控制台输出<br>通过如下配置，设定root日志的输出级别为INFO，appender为控制台输出stdout</p>
<h1 id="LOG4J配置"><a href="#LOG4J配置" class="headerlink" title="LOG4J配置"></a>LOG4J配置</h1><p>log4j.rootCategory=INFO, stdout</p>
<h1 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h1><p>log4j.appender.stdout=org.apache.log4j.ConsoleAppender<br>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout<br>log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L - %m%n<br>输出到文件<br>在开发环境，我们只是输出到控制台没有问题，但是到了生产或测试环境，或许持久化日志内容，方便追溯问题原因。可以通过添加如下的appender内容，按天输出到不同的文件中去，同时还需要为log4j.rootCategory添加名为file的appender，这样root日志就可以输出到logs/all.log文件中了。</p>
<p>#<br>log4j.rootCategory=INFO, stdout, file</p>
<h1 id="root日志输出"><a href="#root日志输出" class="headerlink" title="root日志输出"></a>root日志输出</h1><p>log4j.appender.file=org.apache.log4j.DailyRollingFileAppender<br>log4j.appender.file.file=logs/all.log<br>log4j.appender.file.DatePattern=’.’yyyy-MM-dd<br>log4j.appender.file.layout=org.apache.log4j.PatternLayout<br>log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L - %m%n<br>分类输出<br>当我们日志量较多的时候，查找问题会非常困难，常用的手段就是对日志进行分类，比如：</p>
<p>可以按不同package进行输出。通过定义输出到logs/my.log的appender，并对com.didispace包下的日志级别设定为DEBUG级别、appender设置为输出到logs/my.log的名为didifile的appender。</p>
<h1 id="com-didispace包下的日志配置"><a href="#com-didispace包下的日志配置" class="headerlink" title="com.didispace包下的日志配置"></a>com.didispace包下的日志配置</h1><p>log4j.category.com.didispace=DEBUG, didifile</p>
<h1 id="com-didispace下的日志输出"><a href="#com-didispace下的日志输出" class="headerlink" title="com.didispace下的日志输出"></a>com.didispace下的日志输出</h1><p>log4j.appender.didifile=org.apache.log4j.DailyRollingFileAppender<br>log4j.appender.didifile.file=logs/my.log<br>log4j.appender.didifile.DatePattern=’.’yyyy-MM-dd<br>log4j.appender.didifile.layout=org.apache.log4j.PatternLayout<br>log4j.appender.didifile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L —- %m%n<br>可以对不同级别进行分类，比如对ERROR级别输出到特定的日志文件中，具体配置可以如下。<br>log4j.logger.error=errorfile  </p>
<h1 id="error日志输出"><a href="#error日志输出" class="headerlink" title="error日志输出"></a>error日志输出</h1><p>log4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppender<br>log4j.appender.errorfile.file=logs/error.log<br>log4j.appender.errorfile.DatePattern=’.’yyyy-MM-dd<br>log4j.appender.errorfile.Threshold = ERROR<br>log4j.appender.errorfile.layout=org.apache.log4j.PatternLayout<br>log4j.appender.errorfile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L - %m%n<br>本文主要介绍如何在spring boot中引入log4j，以及一些基础用法，对于更多log4j的用法，还请参考log4j官方网站</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用-Async实现异步调用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用-Async实现异步调用/" class="article-date">
  	<time datetime="2016-06-15T09:28:17.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用-Async实现异步调用/">SpringBoot中使用@Async实现异步调用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用@Async实现异步调用<br>2016年05月16日 标签：Spring Boot<br>什么是“异步调用”？</p>
<p>“异步调用”对应的是“同步调用”，同步调用指程序按照定义顺序依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；异步调用指程序在顺序执行时，不等待异步调用的语句返回结果就执行后面的程序。</p>
<p>同步调用<br>下面通过一个简单示例来直观的理解什么是同步调用：</p>
<p>定义Task类，创建三个处理函数分别模拟三个执行任务的操作，操作消耗时间随机取（10秒内）<br>@Component<br>public class Task {</p>
<pre><code>public static Random random =new Random();

public void doTaskOne() throws Exception {
    System.out.println(&quot;开始做任务一&quot;);
    long start = System.currentTimeMillis();
    Thread.sleep(random.nextInt(10000));
    long end = System.currentTimeMillis();
    System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);
}

public void doTaskTwo() throws Exception {
    System.out.println(&quot;开始做任务二&quot;);
    long start = System.currentTimeMillis();
    Thread.sleep(random.nextInt(10000));
    long end = System.currentTimeMillis();
    System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);
}

public void doTaskThree() throws Exception {
    System.out.println(&quot;开始做任务三&quot;);
    long start = System.currentTimeMillis();
    Thread.sleep(random.nextInt(10000));
    long end = System.currentTimeMillis();
    System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);
}
</code></pre><p>}<br>在单元测试用例中，注入Task对象，并在测试用例中执行doTaskOne、doTaskTwo、doTaskThree三个函数。<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(classes = Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private Task task;

@Test
public void test() throws Exception {
    task.doTaskOne();
    task.doTaskTwo();
    task.doTaskThree();
}
</code></pre><p>}<br>执行单元测试，可以看到类似如下输出：<br>开始做任务一<br>完成任务一，耗时：4256毫秒<br>开始做任务二<br>完成任务二，耗时：4957毫秒<br>开始做任务三<br>完成任务三，耗时：7173毫秒<br>任务一、任务二、任务三顺序的执行完了，换言之doTaskOne、doTaskTwo、doTaskThree三个函数顺序的执行完成。</p>
<p>异步调用<br>上述的同步调用虽然顺利的执行完了三个任务，但是可以看到执行时间比较长，若这三个任务本身之间不存在依赖关系，可以并发执行的话，同步调用在执行效率方面就比较差，可以考虑通过异步调用的方式来并发执行。</p>
<p>在Spring Boot中，我们只需要通过使用@Async注解就能简单的将原来的同步函数变为异步函数，Task类改在为如下模式：</p>
<p>@Component<br>public class Task {</p>
<pre><code>@Async
public void doTaskOne() throws Exception {
    // 同上内容，省略
}

@Async
public void doTaskTwo() throws Exception {
    // 同上内容，省略
}

@Async
public void doTaskThree() throws Exception {
    // 同上内容，省略
}
</code></pre><p>}<br>为了让@Async注解能够生效，还需要在Spring Boot的主程序中配置@EnableAsync，如下所示：</p>
<p>@SpringBootApplication<br>@EnableAsync<br>public class Application {</p>
<pre><code>public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}
</code></pre><p>}<br>此时可以反复执行单元测试，您可能会遇到各种不同的结果，比如：</p>
<p>没有任何任务相关的输出<br>有部分任务相关的输出<br>乱序的任务相关的输出<br>原因是目前doTaskOne、doTaskTwo、doTaskThree三个函数的时候已经是异步执行了。主程序在异步调用之后，主程序并不会理会这三个函数是否执行完成了，由于没有其他需要执行的内容，所以程序就自动结束了，导致了不完整或是没有输出任务相关内容的情况。</p>
<p>注： @Async所修饰的函数不要定义为static类型，这样异步调用不会生效</p>
<p>异步回调<br>为了让doTaskOne、doTaskTwo、doTaskThree能正常结束，假设我们需要统计一下三个任务并发执行共耗时多少，这就需要等到上述三个函数都完成调动之后记录时间，并计算结果。</p>
<p>那么我们如何判断上述三个异步调用是否已经执行完成呢？我们需要使用Future<t>来返回异步调用的结果，就像如下方式改造doTaskOne函数：</t></p>
<p>@Async<br>public Future<string> doTaskOne() throws Exception {<br>    System.out.println(“开始做任务一”);<br>    long start = System.currentTimeMillis();<br>    Thread.sleep(random.nextInt(10000));<br>    long end = System.currentTimeMillis();<br>    System.out.println(“完成任务一，耗时：” + (end - start) + “毫秒”);<br>    return new AsyncResult&lt;&gt;(“任务一完成”);<br>}<br>按照如上方式改造一下其他两个异步函数之后，下面我们改造一下测试用例，让测试在等待完成三个异步调用之后来做一些其他事情。</string></p>
<p>@Test<br>public void test() throws Exception {</p>
<pre><code>long start = System.currentTimeMillis();

Future&lt;String&gt; task1 = task.doTaskOne();
Future&lt;String&gt; task2 = task.doTaskTwo();
Future&lt;String&gt; task3 = task.doTaskThree();

while(true) {
    if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {
        // 三个任务都调用完成，退出循环等待
        break;
    }
    Thread.sleep(1000);
}

long end = System.currentTimeMillis();

System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);
</code></pre><p>}<br>看看我们做了哪些改变：</p>
<p>在测试用例一开始记录开始时间<br>在调用三个异步函数的时候，返回Future<string>类型的结果对象<br>在调用完三个异步函数之后，开启一个循环，根据返回的Future<string>对象来判断三个异步函数是否都结束了。若都结束，就结束循环；若没有都结束，就等1秒后再判断。<br>跳出循环之后，根据结束时间 - 开始时间，计算出三个任务并发执行的总耗时。<br>执行一下上述的单元测试，可以看到如下结果：</string></string></p>
<p>开始做任务一<br>开始做任务二<br>开始做任务三<br>完成任务三，耗时：37毫秒<br>完成任务二，耗时：3661毫秒<br>完成任务一，耗时：7149毫秒<br>任务全部完成，总耗时：8025毫秒<br>可以看到，通过异步调用，让任务一、二、三并发执行，有效的减少了程序的总运行时间。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 菜菜
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>