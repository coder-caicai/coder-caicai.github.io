<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>菜菜的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="菜菜的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="菜菜的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="菜菜的博客">
<meta property="og:description" content="菜菜的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="菜菜的博客">
<meta name="twitter:description" content="菜菜的博客">
  
    <link rel="alternative" href="/atom.xml" title="菜菜的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">菜菜</a></h1>
		</hgroup>

		
		<p class="header-subtitle">菜菜的博客</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags">标签</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/memcached/" style="font-size: 10px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/soa/" style="font-size: 20px;">soa</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">菜菜</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">菜菜</h1>
			</hgroup>
			
			<p class="header-subtitle">菜菜的博客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">标签</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/12/hello-world/" class="article-date">
  	<time datetime="2016-06-12T17:13:43.000Z" itemprop="datePublished">2016-06-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-如何使用GoEasy实现web实时推送" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/05/如何使用GoEasy实现web实时推送/" class="article-date">
  	<time datetime="2016-06-05T21:32:58.000Z" itemprop="datePublished">2016-06-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/05/如何使用GoEasy实现web实时推送/">如何使用GoEasy实现web实时推送</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前项目需要做一个推送功能，最开始我没有想过用第三方推送服务。想着可以用已知技术方式完成，例如定时到服务器看看是否有新的消息，有的话，就读取下来并显示，但是这种方式很浪费客户以及服务器的资源，当然这种方式在我们项目里是不可取的。再后来我在网上搜了一些，说是可以用web socket实现我的功能，但是我在网上查了一下使用方式，看了一上午一头雾水。即使我可以一周两周内用websocket实现我的推送，那我又拿什么来保证我自己写的推送程序的到达率和速度呢？维护成本一定也会随着增加！况且我们也不允许花太多开发成本在这个项目上！</p>
<p>经过上面的一番周折后，我跟项目组提出使用第三方的推送服务，原因很简单，第三方推送服务可以满足我们的需求，缩短我们的开发测试维护成本，术业有专攻，它们在推送方面更有优势，服务质量也有保证！经过几番对比后，我们最终决定使用了GoEasy推送。 它真正的从根本上解决了我们的问题！对于他们的服务质量很满意，注册成功后，你可以获得他们的联系方式，问题处理得很及时，不像有些公司的客服，发封邮件好几天都没有任何信息！从而也解决了我们的后顾之忧！</p>
<p>GoEasy实现向特定用户群推送的原理:<br>知道了他们的推送原理，可以更加方便我们了解他们的服务，以及理解我们写的代码。其实原理很简单，只需要确定哪些用户需要接收信息，然后让这些用户都订阅一个相同的channel（频道）。 然后再往这个平台上推送消息即可！所有关键在于channel，channel一致，则可以接收到信息，否则收不到！</p>
<p>对于订阅必须要的信息有：Appkey, channel<br>对于推送必须要的信息有：Appkey, channel, content</p>
<p>废话不多说，直接进入正题，如何实现：</p>
<p>从GoEasy获取appkey<br>appkey是验证用户的有效性的唯一标识。<br>注册账号: GoEasy官网：<a href="https://goeasy.io" target="_blank" rel="external">https://goeasy.io</a><br>用注册好的账号登录到GoEasy的后台管理系统，创建您自己应用（application）.<br>Application创建好之后系统会自动为您生成appkey<br>系统会生成两个keys，一个Super key和一个Subscribe key；它们的区别在于前者既可以订阅又可以推送，但后者只能用于订阅。</p>
<p>用GoEasy实现订阅（接收）的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.goeasy.io/goeasy.js&quot;&gt;&lt;/script&gt;     </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var goEasy = new GoEasy(&#123;appkey: &apos;your appkey&apos;&#125;);</span><br><span class="line">    goEasy.subscribe(&#123;</span><br><span class="line">        channel: &apos;your_channel&apos;,</span><br><span class="line">        onMessage: function(message)&#123;</span><br><span class="line">            alert(&apos;接收到消息:&apos;+message.content);//拿到了信息之后，你可以做你任何想做的事</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>有了这几行代码后，只要保证网络畅通的情况下，页面会自动弹出你从任何平台上推送的信息。</p>
<p>用GoEasy的三种方式实现推送及接收<br>目前GoEasy支持三种推送方式： Java后台推送（它们有提供JAVA SDK和 maven远程仓库）， JS推送，RestAPI推送（有了RestAPI，我们就可以用PHP, .NET, Ruby…来推送信息了，很方便）</p>
<p>说了这么多，来我们看一下怎么用GoEasy的三种方式分别实现推送吧.</p>
<p>用GoEasy SDK推送<br>引入GoEasy SDK<br>方式一，直接在goeasy的官网上进行下载<br>GoEasy SDK下载链接：<a href="http://maven.goeasy.io/service/local/artifact/maven/redirect?r=releases&amp;g=io.goeasy&amp;a=goeasy-sdk&amp;v=LATEST&amp;e=jar" target="_blank" rel="external">http://maven.goeasy.io/service/local/artifact/maven/redirect?r=releases&amp;g=io.goeasy&amp;a=goeasy-sdk&amp;v=LATEST&amp;e=jar</a><br>方式二，用maven远程库直接导入到项目中，下面是GoEasy远程maven库的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">    &lt;id&gt;goeasy&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;goeasy&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.goeasy.io/content/repositories/releases/&lt;/url&gt;</span><br><span class="line">&lt;/repository&gt;</span><br><span class="line">…</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.goeasy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;goeasy-sdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>实例化GoEasy对象并推送<br>GoEasy goEasy = new GoEasy(“your appkey”);<br>goEasy.publish(‘your_channel’, ‘First message’);<br>JavaScript推送<br>引入goeasy.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.goeasy.io/goeasy.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>实例化Goeasy对象，并用publish函数进行推送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var goEasy = new GoEasy(&#123;appkey: &apos;your appkey&apos;&#125;);</span><br><span class="line">    goEasy. publish (&#123;</span><br><span class="line">        channel: &apos;your_channel&apos;, </span><br><span class="line">        message: &apos;Second message！&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>用RestAPI进行推送<br>URL: <a href="https://goeasy.io/goeasy/publish" target="_blank" rel="external">https://goeasy.io/goeasy/publish</a><br>Method: post<br>参数：appkey, channel, content<br>例如：<a href="https://goeasy.io/goeasy/publish?appkey={your_appkey}&amp;channel={your_channel}&amp;content={your_message}" target="_blank" rel="external">https://goeasy.io/goeasy/publish?appkey={your_appkey}&amp;channel={your_channel}&amp;content={your_message}</a><br>GoEasy官网：<a href="https://goeasy.io" target="_blank" rel="external">https://goeasy.io</a><br>快速入门：<a href="https://goeasy.io/www/started.jsp" target="_blank" rel="external">https://goeasy.io/www/started.jsp</a><br>文档下载：<a href="https://goeasy.io/www/docs.jsp" target="_blank" rel="external">https://goeasy.io/www/docs.jsp</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-汽车之家配置管理系统AutoCMS" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/03/汽车之家配置管理系统AutoCMS/" class="article-date">
  	<time datetime="2016-05-03T23:49:37.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/汽车之家配置管理系统AutoCMS/">汽车之家配置管理系统AutoCMS</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Break Wang<br>Be slow to promise and quick to perform.</p>
<p> Email<br> Twitter<br> Google+<br>汽车之家配置管理系统AutoCMS</p>
<p>介绍</p>
<p>作者介绍</p>
<p>本文作者是王显宝wangxianbao@autohome.com.cn,主要负责AutoCMS的开发工作和缓存平台的运维工作，擅长python自动化运维,分布式缓存和分布式文件系统应用管理。</p>
<p>团队介绍</p>
<p>我们是汽车之家运维团队，是汽车之家技术部里最为核心的团队，由op和dev共同组成。我们的目标是为汽车之家集团打造一个高性能，高可扩展，低成本，并且稳定可靠的网站基础设施平台。</p>
<p>团队技术博客地址为 <a href="http://autohomeops.github.io/" target="_blank" rel="external">http://autohomeops.github.io/</a></p>
<p>联系方式：可以通过邮件或者在官方技术博客留言跟我们交流。</p>
<p>大纲</p>
<ol>
<li>前言</li>
<li>AutoCMS使用方法介绍</li>
<li>系统架构说明</li>
<li>配置案例</li>
<li>小结<br>1.前言</li>
</ol>
<p>AutoCMS 是汽车之家目前正在使用的统一配置管理工具，本文将详细介绍该系统的使用方法和架构实现。 先来回顾下汽车之家软件部署和配置文件管理的经历的几个阶段:</p>
<p>原始阶段（依靠手工部署，wiki制定规范）<br>最初阶段软件部署和配置文件管理完全依赖人力完成。部署新业务，运维根据研发测试环境的软件版本，去官网下载软件包，在服务器上编译安装，然后根据研发需求，手工配置文件，启动服务。该阶段暴露出诸多问题：<br>软件包的来源没有强制规范，带来了很大的安全隐患。<br>新业务上线或者业务紧急扩容，运维投入大量人力来完成繁重的体力劳动。<br>部署目录标准化依赖wiki规范维护，人力部署的时候经常会出现问题<br>半自动化阶段（依赖人力打包，yum方式部署）<br>随着运维自动化的推行，搭建自己的yum源，自己打包来规范软件版本来源和部署目录。需要批量部署的时候，逐台登录服务器执行yum install 安装相关的软件包即可，该阶段已经节省了很大的人力，不过依然需要逐台登录服务器去修改配置文件才能够满足上线需求。配置文件变更前的备份和故障后的恢复依然需要人力维护。<br>自动化阶段<br>现在正在使用的管理系统AutoCMS，实现页面化管理软件部署和配置文件，实现快速批量管理软件。<br>下面将详细介绍一下我们正在使用的AutoCMS。</p>
<p>2.AutoCMS使用方法介绍</p>
<p>AutoCMS 是基于puppet实现的软件部署和配置文件管理的一套系统，避免手动安装部署软件，提供可靠的软件标准化部署，配置文件和基础服务的管理服务。 本系统主要实现以下几点功能：</p>
<p>批量部署软件包<br>页面管理软件的配置文件变更，支持备份和回滚<br>多环境部署，开发，测试，线上环境相互隔离<br>灰度推送配置<br>远程执行安全的命令<br>基本的统计功能<br>使用者操作流程如下：</p>
<p>创建主机组</p>
<p>主机组是需要批量部署同一个软件或者下发相同配置的主机的集合，创建主机组的同时需要关联一下配置模块，该配置模块是提前写好的puppet模块。</p>
<p>添加主机</p>
<p>将需要部署该模块的主机加入该组内（本系统中主机的输入源是cmdb接口）</p>
<p>选择环境</p>
<p>根据需求选择该主机的环境，各个环境的配置数据独立存储，彼此不受影响。</p>
<p>配置部署参数</p>
<p>根据配置模块不同，编写配置文件，生成不同的配置页面，业务运维只要在页面上选择相应的参数，puppet会根据这些参数生成相应的配置文件。</p>
<p>推送配置</p>
<p>业务运维再前端页面配置完成后，返回主机组管理页面，选择主机并进行推送配置，便会触发相关主机的puppet agent 运行，部署相应的软件和配置。</p>
<p>3.系统架构说明</p>
<p>AutoCMS使用django作为前端框架，后端部署程序主要基于puppet实现，通过puppet的enc和report功能实现完整的部署和配置逻辑，整体架构如下：</p>
<p>简要分析下：</p>
<p>前端配置页面<br>由于各个软件配置选项不同，所以前端的软件参数配置页面要采用配置文件动态生成。<br>数据存储<br>设计初期，我们在mysql和MongoDB之间选择了MongoDB，主要出于一下几点考虑：<br>Schema-less,json风格存储：由于配置数据根据软件的不同，其数据不能依靠key-value能够存放的，每个软件的配置项可能会有自定义的结构，所以采用了json格式来处理，而MongoDB的bson恰好能够满足需求，省去了在mysql中频繁使用外键。此外，json格式数据易于掌握和理解，存储的数据一目了然。</p>
<p>CRUD方便快捷，支持范围查询和正则查询，还支持支持upsert选项（如果不存在则插入）。</p>
<p>与其他nosql产品相比，我们对mongodb的持久化和高可用方案更加熟悉。</p>
<p>部署实施层</p>
<p>该部分是通过puppet模块实现，模块中引用的参数通过自定义facter或者使用enc来读取配置存储的MongoDB获得，</p>
<p>多实例部署的实现：<br>一台主机的多实例部署通过create_resources函数实现，例如一台主机需要配置多个tomcat实例，数据会是如下结构：  </p>
<p>多环境分离实现： 本系统中puppet代码部分有git作为版本控制，通过git自身的多分支的特性来做puppet代码层面的环境分离。根据需求来执行不同分支的puppet代码即可。<br>4.配置案例</p>
<p>下面以tomcat自动部署模块为例，进行详细介绍：</p>
<p>根据部署需求，设计出配置数参数的存储结构<br>填写前端布局的配置文件，自动生成前端配置页面。 </p>
<p>编写puppet自动部署模块。</p>
<p>编写enc转换程序<br>以上准备工作做好之后，系统上线，运维可以创建主机组，关联tomcat模块，将需要批量部署的主机加入该组内，并进行参数配置<br>配置完成后，进行灰度发布验证没问题后，进行全量推送，观察状态，配置完成。 </p>
<ol>
<li>小结</li>
</ol>
<p>随着云时代的到来，很多服务器可以定制镜像实现所需的运行环境，不过随着业务规模的扩大，服务器的个性化配置会越来越多，镜像的维护工作也会逐步增加，使用AutoCMS可以灵活的解决这个问题。把各自的配置需求写成配置模块，并把服务器分组，批量推送下去，可以节省运维人员很多体力劳动。让运维人员将精力投入到更有价值的工作中。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soa/">soa</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-dubbox" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/dubbox/" class="article-date">
  	<time datetime="2016-04-29T00:26:34.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/dubbox/">dubbox</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox</a><br>Dubbox now means Dubbo eXtensions. If you know java, javax and dubbo, you know what dubbox is :)<br>Dubbox adds features like RESTful remoting, Kyro/FST serialization, etc to the popular dubbo service framework. It’s been used by several projects of dangdang.com, which is one of the major e-commerce companies in China.<br>主要贡献者</p>
<p>沈理 当当网 shenli@dangdang.com<br>王宇轩 当当网 wangyuxuan@dangdang.com<br>马金凯 韩都衣舍 majinkai@handu.com<br>Dylan 独立开发者 dinguangx@163.com<br>Kangfoo 独立开发者<br>讨论QQ群：258792161 （不限于dubbox，包括SOA设计、互联网技术等等兴趣交流）<br>Dubbox当前的主要功能</p>
<p>支持REST风格远程调用（HTTP + JSON/XML)：基于非常成熟的JBoss RestEasy框架，在dubbo中实现了REST风格（HTTP + JSON/XML）的远程调用，以显著简化企业内部的跨语言交互，同时显著简化企业对外的Open API、无线API甚至AJAX服务端等等的开发。事实上，这个REST调用也使得Dubbo可以对当今特别流行的“微服务”架构提供基础性支持。 另外，REST调用也达到了比较高的性能，在基准测试下，HTTP + JSON与Dubbo 2.x默认的RPC协议（即TCP + Hessian2二进制序列化）之间只有1.5倍左右的差距，详见文档中的基准测试报告。<br>支持基于Kryo和FST的Java高效序列化实现：基于当今比较知名的Kryo和FST高性能序列化库，为Dubbo默认的RPC协议添加新的序列化实现，并优化调整了其序列化体系，比较显著的提高了Dubbo RPC的性能，详见文档中的基准测试报告。<br>支持基于Jackson的JSON序列化：基于业界应用最广泛的Jackson序列化库，为Dubbo默认的RPC协议添加新的JSON序列化实现。<br>支持基于嵌入式Tomcat的HTTP remoting体系：基于嵌入式tomcat实现dubbo的HTTP remoting体系（即dubbo-remoting-http），用以逐步取代Dubbo中旧版本的嵌入式Jetty，可以显著的提高REST等的远程调用性能，并将Servlet API的支持从2.5升级到3.1。（注：除了REST，dubbo中的WebServices、Hessian、HTTP Invoker等协议都基于这个HTTP remoting体系）。<br>升级Spring：将dubbo中Spring由2.x升级到目前最常用的3.x版本，减少版本冲突带来的麻烦。<br>升级ZooKeeper客户端：将dubbo中的zookeeper客户端升级到最新的版本，以修正老版本中包含的bug。<br>支持完全基于Java代码的Dubbo配置：基于Spring的Java Config，实现完全无XML的纯Java代码方式来配置dubbo<br>调整Demo应用：暂时将dubbo的demo应用调整并改写以主要演示REST功能、Dubbo协议的新序列化方式、基于Java代码的Spring配置等等。<br>修正了dubbo的bug 包括配置、序列化、管理界面等等的bug。<br>注：dubbox和dubbo 2.x是兼容的，没有改变dubbo的任何已有的功能和配置方式（除了升级了spring之类的版本）<br>文档资料</p>
<p>在Dubbo中开发REST风格的远程调用（RESTful Remoting）<br>在Dubbo中使用高效的Java序列化（Kryo和FST）<br>使用JavaConfig方式配置dubbox<br>Dubbo Jackson序列化使用说明<br>Demo应用简单运行指南<br>Dubbox@InfoQ<br>Dubbox Wiki （由社区志愿者自由编辑的）<br>版本</p>
<p>详见：<a href="https://github.com/dangdangdotcom/dubbox/releases" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox/releases</a><br>dubbox-2.8.0：主要支持REST风格远程调用、支持Kryo和FST序列化、升级了Spring和Zookeeper客户端、调整了demo应用等等<br>dubbox-2.8.1：主要支持基于嵌入式tomcat的http-remoting，优化了REST客户端性能，在REST中支持限制服务端接纳的最大HTTP连接数等等<br>dubbox-2.8.2：<br>支持REST中的HTTP logging，包括HTTP header的字段和HTTP body中的消息体，方便调试、日志纪录等等<br>提供辅助类便于REST的中文处理<br>改变使用@Reference annotation配置时的异常处理方式，即当用annotation配置时，过去dubbo在启动期间不抛出依赖服务找不到的异常，而是在具体调用时抛出NPE，这与用XML配置时的行为不一致。<br>较大的充实了Dubbo REST的文档<br>dubbox-2.8.3：<br>在REST中支持dubbo统一的方式用bean validation annotation作参数校验（沈理）<br>在RpcContext上支持获取底层协议的Request/Response（沈理）<br>支持采用Spring的Java Config方式配置dubbo（马金凯）<br>在Dubbo协议中支持基于Jackson的json序列化（Dylan）<br>在Spring AOP代理过的对象上支持dubbo annotation配置（Dylan）<br>修正Dubbo管理界面中没有consumer时出现空指针异常（马金凯）<br>修正@Reference annotation中protocol设置不起作用的bug（沈理）<br>修正@Reference annotation放在setter方法上即会出错的bug（Dylan）<br>依赖</p>
<p>从dubbox-2.8.4开始，所有依赖库的使用方式将和dubbo原来的一样：即如果要使用REST、Kyro、FST、Jackson等功能，需要用户自行手工添加相关的依赖。例如：<br>REST风格远程调用</p>
<dependency><br>    <groupid>org.jboss.resteasy</groupid><br>    <artifactid>resteasy-jaxrs</artifactid><br>    <version>3.0.7.Final</version><br></dependency><br><dependency><br>    <groupid>org.jboss.resteasy</groupid><br>    <artifactid>resteasy-client</artifactid><br>    <version>3.0.7.Final</version><br></dependency><br><dependency><br>    <groupid>javax.validation</groupid><br>    <artifactid>validation-api</artifactid><br>    <version>1.0.0.GA</version><br></dependency>

<!-- 如果要使用json序列化 -->
<dependency><br>    <groupid>org.jboss.resteasy</groupid><br>    <artifactid>resteasy-jackson-provider</artifactid><br>    <version>3.0.7.Final</version><br></dependency>

<!-- 如果要使用xml序列化 -->
<dependency><br>    <groupid>org.jboss.resteasy</groupid><br>    <artifactid>resteasy-jaxb-provider</artifactid><br>    <version>3.0.7.Final</version><br></dependency>

<!-- 如果要使用netty server -->
<dependency><br>    <groupid>org.jboss.resteasy</groupid><br>    <artifactid>resteasy-netty</artifactid><br>    <version>3.0.7.Final</version><br></dependency>

<!-- 如果要使用Sun HTTP server -->
<dependency><br>    <groupid>org.jboss.resteasy</groupid><br>    <artifactid>resteasy-jdk-http</artifactid><br>    <version>3.0.7.Final</version><br></dependency>

<!-- 如果要使用tomcat server -->
<p><dependency><br>    <groupid>org.apache.tomcat.embed</groupid><br>    <artifactid>tomcat-embed-core</artifactid><br>    <version>8.0.11</version><br></dependency></p>
<p><dependency><br>    <groupid>org.apache.tomcat.embed</groupid><br>    <artifactid>tomcat-embed-logging-juli</artifactid><br>    <version>8.0.11</version><br></dependency><br>Kyro序列化</p>
<p><dependency><br>    <groupid>com.esotericsoftware.kryo</groupid><br>    <artifactid>kryo</artifactid><br>    <version>2.24.0</version><br></dependency></p>
<p><dependency><br>    <groupid>de.javakaffee</groupid><br>    <artifactid>kryo-serializers</artifactid><br>    <version>0.26</version><br></dependency><br>FST序列化</p>
<p><dependency><br>    <groupid>de.ruedigermoeller</groupid><br>    <artifactid>fst</artifactid><br>    <version>1.55</version><br></dependency><br>Jackson序列化</p>
<p><dependency><br>    <groupid>com.fasterxml.jackson.core</groupid><br>    <artifactid>jackson-core</artifactid><br>    <version>2.3.3</version><br></dependency></p>
<p><dependency><br>    <groupid>com.fasterxml.jackson.core</groupid><br>    <artifactid>jackson-databind</artifactid><br>    <version>2.3.3</version><br></dependency><br>FAQ（暂存）</p>
<p>Dubbox需要什么版本的JDK？</p>
<p>目前最好在JDK 1.7以上运行<br>Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？</p>
<p>可以的，而且是自动集成的，也就是你在dubbo中开发的所有REST服务都会自动注册到服务册中心和监控中心，可以通过它们做管理。<br>但是，只有当REST的消费端也是基于dubbo的时候，注册中心中的许多服务治理操作才能完全起作用。而如果消费端是非dubbo的，自然不受注册中心管理，所以其中很多操作是不会对消费端起作用的。<br>Dubbo REST中如何实现负载均衡和容错（failover）？</p>
<p>如果dubbo REST的消费端也是dubbo的，则Dubbo REST和其他dubbo远程调用协议基本完全一样，由dubbo框架透明的在消费端做load balance、failover等等。<br>如果dubbo REST的消费端是非dubbo的，甚至是非java的，则最好配置服务提供端的软负载均衡机制，目前可考虑用LVS、HAProxy、 Nginx等等对HTTP请求做负载均衡。<br>JAX-RS中重载的方法能够映射到同一URL地址吗？</p>
<p><a href="http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params" target="_blank" rel="external">http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params</a><br>JAX-RS中作POST的方法能够接收多个参数吗？</p>
<p><a href="http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects" target="_blank" rel="external">http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soa/">soa</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Venus-唯品会分布式框架" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/Venus-唯品会分布式框架/" class="article-date">
  	<time datetime="2016-04-29T00:25:23.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/Venus-唯品会分布式框架/">Venus----唯品会分布式框架</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://wiki.hexnova.com/display/Venus/HOME" target="_blank" rel="external">http://wiki.hexnova.com/display/Venus/HOME</a></p>
<p> HOME</p>
<p>附件：1<br>被Struct添加，被Struct最后更新于2015-Aug-26  (查看更改)<br>Venus（New Version：3.2.14） 是什么？</p>
<p>它是由(Venus service framework)+服务路由产品（Venus-Bus）+服务注册中心(Venus-Registry) 组合而成，提供远程服务。它着 开发简单、高性能、高并发能力 的服务端框架。<br>客户端与服务端之间的通讯对开发人员完全透明<br>他跟目前我们经常用到的框架：axis、CXF、Hessian WebService、Jboss Remoting等框架类似。<br>系统功能目标：<br>提供高性能的服务通讯框架<br>具备性能监控（可以清晰的看到每个服务执行的时间、过长可以通过监控告警出去）<br>具备流量控制（每个服务每个时刻的调用次数、每天的峰值情况、）<br>访问控制（服务的授权控制）<br>提供可选择性服务数据缓存（cache支持，key采用表达式，由框架提供缓存支持，而不需要编写任何cache相关的代码）<br>提供框架进行再次研发能力，提供interceptor、validator等接口。<br>提供高性能的服务总线（Venus-Bus），能够轻易接入高性能的服务总线。（Venus-Bus项目支持，针对该venus的协议，以后接入服务总线轻而易举）<br>开发方面：<br>服务接口定义清晰(接口、参数、校验、以及服务鉴权)<br>自动生成接口文档，以方便阅读接口声明<br>客户端框架快速开发、提供多种语言版本的客户端<br>提供3种服务调用方式（同步、异步、回调）<br>服务端框架提供多种协议提供服务，而不需要做额外的开发<br>    语言支持情况<br>目前客户端SDK暂时只有java、PHP语言版本<br>服务端面向java语言<br>java 语言开发例子<br>演讲稿下载</p>
<p>Venus演讲稿.pdf<br>开发人员的关注点</p>
<ol>
<li>如何服务化</li>
</ol>
<p>采用接口与实现分离，服务接口是一种契约，他与我们开发web Service类似。<br>java开发语言：采用对程序员友好的接口申明形式，开发人员不需要关心客户端与服务端之间的传输协议。<br>其他语言：可以通过该框架提供自定义协议或者Http协议（http协议即将在2.1.0版本release出来）进行交互</p>
<ol>
<li>服务接口定制</li>
</ol>
<p>定义服务接口<br>接口参数命名<br>定义参数校验规则<br>Java语言服务接口尽量不要依赖其他项目. 接口层面只需要接口相关的参数对象类与服务类<br>异常定义</p>
<ol>
<li><p>接口参数校验</p>
</li>
<li><p>提供3种交互方式</p>
<p>请求应答模式：普通的request、response，一般用于接口有返回值<br>异步请求模式：通常用于接口无返回值，客户端并不关心服务器的处理结果，也不用关心服务器处理多少时间<br>异步回调模式：接口无返回值，处理通常消化大量时间，需要服务端通知处理结果的业务接口<br>源代码：</p>
</li>
</ol>
<p>demo 的svn 地址：svn://svn.hexnova.com/venus/venus-helloworld/trunk<br>框架svn地址： svn://svn.hexnova.com/venus/venus-framework/trunk<br>svn的用户名：guest<br>svn密码：guest<br>Maven Repository</p>
<p><repository><id>hexnova-open</id><url><a href="http://maven.hexnova.com/nexus/content/groups/hexnova-open" target="_blank" rel="external">http://maven.hexnova.com/nexus/content/groups/hexnova-open</a></url><releases><enabled>true</enabled><updatepolicy>never</updatepolicy></releases><snapshots><enabled>true</enabled><updatepolicy>always</updatepolicy></snapshots></repository><br>目前版本情况：</p>
<p>trunk是最新开发版本，会不停有新东西进入<br>稳定版本: 3.2.14<br>最新版本:3.2.14<br>版本发布Blog地址： <a href="http://wiki.hexnova.com/pages/viewrecentblogposts.action?key=Venus" target="_blank" rel="external">http://wiki.hexnova.com/pages/viewrecentblogposts.action?key=Venus</a><br>开发人员与blog</p>
<p>日志</p>
<p>日志: Venus 3.2.12 Release 创建：<br>Struct<br>2014-Sep-05<br>Venus<br>日志: Venus 3.2.10 Release 创建：<br>Struct<br>2014-Jun-25<br>Venus<br>日志: Venus 3.2.3 Released 创建：<br>Struct<br>2014-Feb-19<br>Venus<br>日志: Venus 3.0.9 Released 创建：<br>Struct<br>2013-Dec-25<br>Venus<br>日志: Venus 3.0.6 Released 创建：<br>Struct<br>2013-Nov-22<br>Venus<br>日志: Venus 3.0.4 Released 创建：<br>Struct<br>2013-Nov-14<br>Venus<br>日志: Venus 3.0.3 Released 创建：<br>Struct<br>2013-Oct-25<br>Venus<br>日志: Venus 3.0.2 Released 创建：<br>Struct<br>2013-Oct-21<br>Venus<br>日志: Venus 3.0.1 Released 创建：<br>Struct<br>2013-Oct-14<br>Venus<br>日志: Venus 2.3.0 Released 创建：<br>Struct<br>2012-Oct-08<br>Venus<br>日志: Venus 2.2.7 Released 创建：<br>Struct<br>2012-Sep-24<br>Venus<br>日志: Venus 2.2.6 Released 创建：<br>Struct<br>2012-Jun-28<br>Venus<br>日志: Venus 2.2.3 Released 创建：<br>Struct<br>2012-May-21<br>Venus<br>日志: Venus 2.0.4 Released 创建：<br>Struct<br>2012-Mar-31<br>Venus<br>日志: Venus 2.0.3 Released 创建：<br>Struct<br>2012-Mar-23<br>Venus<br>日志: Venus 2.0.1 Released 创建：<br>Struct<br>2012-Jan-02<br>Venus<br>日志: Venus 1.3.0 Released 创建：<br>Struct<br>2011-Dec-07<br>Venus<br>日志: Venus 1.2.0 Released 创建：<br>Struct<br>2011-Dec-01<br>Venus<br>日志: Venus 1.1.0 Released 创建：<br>Struct<br>2011-Nov-28<br>Venus</p>
<p>研发人员列表</p>
<p>昵称    角色    职责    开源社区    目前供职于<br>Struct    Member    负责架构设计、通信框架研发、服务框架研发    Hexnova    上海汽车工业集团<br>Daisy    Member    对象数据序列化、服务接口数据校验、服务框架研发    Hexnova    </p>
<p>Sunng    Member    服务框架研发    Hexnova    </p>
<p>Yuanjian Yi    Member<br>PHP客户端开发    Hexnova<br>上海由你网络科技有限公司<br>huawei    Member<br>服务注册中心    Hexnova </p>
<p>样例：</p>
<p>简单的接口例子：HelloService.java<br>HelloService接口例子<br>package com.meidusa.venus.hello.api;</p>
<p>import com.meidusa.venus.annotations.Endpoint;<br>import com.meidusa.venus.annotations.Param;<br>import com.meidusa.venus.annotations.Service;<br>import com.meidusa.venus.notify.InvocationListener;</p>
<p>/**</p>
<ul>
<li>Service framework的 HelloService 接口例子.<p></p></li>
<li>支持3种调用方式：<p></p></li>
<li></li><li> 请求应答模式：普通的request、response，一般用于接口有返回值</li>
<li></li><li> 异步请求模式：通常用于接口无返回值，客户端并不关心服务器的处理结果，也不用关心服务器处理多少时间</li>
<li></li><li> 异步回调模式：接口无返回值，处理通常消化大量时间，需要服务端通知处理结果的业务接口</li><br>*
<li><p>@author Struct<br><em>
</em>/<br>@Service(name=”HelloService”,version=1)<br>publicinterface HelloService {</p>
<p> /**</p>
<ul>
<li>无返回结果的服务调用，支持回调方式，该服务在通讯层面上为异步调用</li>
<li>@param name</li>
<li>@param invocationListener 客户端的回调接口<br>*/<br>@Endpoint(name=”sayHelloWithCallbak”)<br>publicabstract void sayHello(@Param(name=”name”) String name,<pre><code>@Param(name=&quot;callback&quot;) InvocationListener&lt;Hello&gt; invocationListener);
</code></pre>/**</li>
<li>无返回结果的服务调用，支持同步或者异步调用,</li>
<li>该接口申明：同步，并且接口申明异常</li>
<li><p>@param name<br>*/<br>@Endpoint(name=”sayHello”,async=false)<br>publicabstract void sayHello(@Param(name=”name”) String name) throws HelloNotFoundException;</p>
<p>/**</p>
</li>
<li>无返回结果的服务调用，支持同步或者异步调用，无异常申明</li>
<li>@param name<br>*/<br>@Endpoint(name=”sayAsyncHello”,async=true)<br>publicabstract void sayAsyncHello(@Param(name=”name”) String name);</li>
</ul>
</li>
</ul>
<pre><code>/**
 * 有返回结果的服务调用，该接口只能支持同步调用
 * @param name
 * @return
 */
@Endpoint(name=&quot;getHello&quot;,timeWait=10000)
publicabstract Hello getHello(@Param(name=&quot;name&quot;) String name);
</code></pre><p>}<br>客户端TestCase编写<br>客户端TestCase<br>package com.meidusa.venus.hello.client;</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<p>import org.junit.Test;<br>import org.junit.runner.RunWith;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.test.context.ContextConfiguration;<br>import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</p>
<p>import com.meidusa.venus.exception.CodedException;<br>import com.meidusa.venus.hello.api.Hello;<br>import com.meidusa.venus.hello.api.HelloNotFoundException;<br>import com.meidusa.venus.hello.api.HelloService;<br>import com.meidusa.venus.notify.InvocationListener;</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(locations=”classpath:/applicationContext-helloworld-client.xml”)<br>public class TestHelloService {</p>
<pre><code>@Autowired
private HelloService helloService;

@Test
public void saySync(){
    System.out.println(helloService.getHello(&quot;jack&quot;));
}

@Test
public void testSyncWithException(){
    try {
        helloService.sayHello(&quot;jack&quot;);
    } catch (HelloNotFoundException e) {
        System.out.println(&quot;throw an user defined HelloNotFoundException&quot;);
    }
}

@Test
public void testAsync(){
    helloService.sayAsyncHello(&quot;jack&quot;);
}

@Test
public void testCallback() throws Exception{
    //为了让回调完成，采用countDownLatch计数器方式，避免testcase主线程运行完成而回调未结束的问题
</code></pre><p>final CountDownLatch latch = new CountDownLatch(1);</p>
<pre><code>              //在正常的使用的代码中这个类需要单实例，避免过多的callback listener导致内存问题
                  InvocationListener&lt;Hello&gt; listener = new InvocationListener&lt;Hello&gt;() {
        public void callback(Hello myobject) {
            System.out.println(&quot; async call back result=&quot;+myobject);
            latch.countDown();
        }

        @Override
        public void onException(Exception e) {
            if(e instanceof CodedException){
                CodedException exception = (CodedException) e;
                System.out.println(&quot; async call back error:&quot;+exception.getErrorCode()+&quot;,message=&quot;+exception.getMessage());
            }else{
                System.out.println(&quot; async call back message=&quot;+e.getMessage());
            }
            latch.countDown();

        }
    };

    helloService.sayHello(&quot;jack&quot;,listener);
    latch.await();
}
</code></pre><p>}<br>服务端的实现<br>服务端对HelloService的简单实现<br>package com.meidusa.venus.hello.impl;</p>
<p>import java.math.BigDecimal;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>import com.meidusa.venus.hello.api.Hello;<br>import com.meidusa.venus.hello.api.HelloNotFoundException;<br>import com.meidusa.venus.hello.api.HelloService;<br>import com.meidusa.venus.notify.InvocationListener;</p>
<p>public class DefaultHelloService implements HelloService {<br>    privateString greeting;<br>    publicString getGreeting() {<br>        return greeting;<br>    }</p>
<pre><code>public void setGreeting(String greeting) {
    this.greeting = greeting;
}
public Hello getHello(String name) {
    Hello hello = new Hello();
    hello.setName(name);
    hello.setGreeting(greeting);
    Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
    hello.setMap(map);
    map.put(&quot;1&quot;, 1);
    map.put(&quot;2&quot;, newLong(2));
    map.put(&quot;3&quot;, newInteger(3));
    hello.setBigDecimal(new BigDecimal(&quot;1.341241233412&quot;));
    return hello;
}

public void sayHello(String name)  throws HelloNotFoundException {
    thrownew HelloNotFoundException(name +&quot; not found&quot;);
}

@Override
public void sayAsyncHello(String name) {
    System.out.println(&quot;method sayAsyncHello invoked&quot;);
}

public void sayHello(String name,
        InvocationListener&lt;Hello&gt; invocationListener) {
    Hello hello = new Hello();
    hello.setName(name);
    hello.setGreeting(greeting);
    Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
    hello.setMap(map);
    map.put(&quot;1&quot;, 1);
    map.put(&quot;2&quot;, newLong(2));
    map.put(&quot;3&quot;, newInteger(3));

    if(invocationListener != null){
        invocationListener.callback(hello);
    }

}
</code></pre><p>}<br>最近的更新</p>
<p>Go语言客户端 go-venus-plugin<br>commented by deephex<br>Jan 22<br>Go语言客户端 go-venus-plugin<br>updated by Struct<br>(view change)<br>Jan 15</p>
<ol>
<li>各种客户端简单使用<br>updated by Struct<br>(view change)<br>Jan 15<br>go-venus-plugin.zip<br>attached by Struct<br>Jan 15<br>go-venus-plugin.zip<br>attached by Struct<br>Jan 15<br>JAVA语言客户端<br>commented by 匿名用户<br>2015-Oct-14<br>HOME<br>commented by wangzhenjun<br>2015-Oct-08<br>HOME<br>updated by Struct<br>(view change)<br>2015-Aug-26<br>JAVA语言客户端<br>commented by 匿名用户<br>2015-Aug-10<br>后端处理线程设置<br>updated by Struct<br>(view change)<br>2015-Jul-29<br>. Venus Http协议<br>updated by Struct<br>(view change)<br>2015-Jun-29<br>venus-http-adaptor-3.2.13-distribution.zip<br>attached by Struct<br>2015-Jun-29<br>JAVA语言客户端<br>updated by Struct<br>(view change)<br>2015-Jun-11<br>HOME<br>commented by zhuo<br>2015-Feb-14<br>Venus 3.2.12 Release<br>commented by sunstar_s<br>2015-Jan-14<br>Venus Eclipse Plugin发布<br>commented by 匿名用户<br>2015-Jan-10<br>Venus Eclipse Plugin发布<br>commented by 匿名用户<br>2015-Jan-05<br>HOME<br>commented by 匿名用户<br>2014-Nov-06<br>HOME<br>commented by 匿名用户<br>2014-Nov-05<br>Venus 3.2.12 Release<br>created by Struct<br>2014-Sep-05<br>More </li>
</ol>
<p>Navigate space</p>
<ol>
<li>各种客户端简单使用</li>
<li>高级使用指南</li>
<li>Architecture</li>
<li>协议以及交互序列图介绍</li>
<li>性能测试工具–Service-benchmark</li>
<li>性能测试(单客户端)</li>
<li><p>极限测试(多客户端)<br>FAQ<br>Venus Eclipse Plugin发布<br>二、其他语言客户端<br>子页面 (10) </p>
<p>隐藏子页面  |  页面重排<br>页面: 1. 各种客户端简单使用<br>页面: 2. 高级使用指南<br>页面: 3. Architecture<br>页面: 4. 协议以及交互序列图介绍<br>页面: 5. 性能测试工具–Service-benchmark<br>页面: 6. 性能测试(单客户端)<br>页面: 7. 极限测试(多客户端)<br>页面: FAQ<br>页面: Venus Eclipse Plugin发布<br>页面: 二、其他语言客户端 </p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soa/">soa</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-新浪开源分布式框架-motan" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/新浪开源分布式框架-motan/" class="article-date">
  	<time datetime="2016-04-29T00:24:27.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/新浪开源分布式框架-motan/">新浪开源分布式框架--motan</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开源地址 <a href="https://github.com/weibocom/motan/wiki/zh_quickstart" target="_blank" rel="external">https://github.com/weibocom/motan/wiki/zh_quickstart</a></p>
<p>zh_quickstart</p>
<p>axb edited this page 2 days ago · 2 revisions<br> Pages 8</p>
<p>Documents</p>
<p>Overview<br>Quick Start<br>User Guide(Preparing)<br>Develop Guide(Preparing)<br>FAQ<br>中文文档</p>
<p>概述<br>快速入门<br>用户指南<br>开发指南(准备中)<br>常见问题<br>Clone this wiki locally</p>
<p> Clone in Desktop<br>快速入门<br>简单调用示例<br>集群调用示例<br>使用Consul作为注册中心<br>使用ZooKeeper作为注册中心<br>快速入门中会给出一些基本使用场景下的配置方式，更详细的使用文档请参考用户指南.<br>如果要执行快速入门介绍中的例子，你需要:<br>JDK 1.7或更高版本。<br>java依赖管理工具，如Maven或Gradle。<br>简单调用示例</p>
<p>在pom中增加依赖</p>
<dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-core</artifactid><br>    <version>0.0.1</version><br></dependency><br><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-transport-netty</artifactid><br>    <version>0.0.1</version><br></dependency>

<!-- only needed for spring-based features -->
<p><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-springsupport</artifactid><br>    <version>0.0.1</version><br></dependency></p>
<p><dependency><br>    <groupid>org.springframework</groupid><br>    <artifactid>spring-context</artifactid><br>    <version>4.2.4.RELEASE</version><br></dependency><br>为调用方和服务方创建接口。<br>src/main/java/quickstart/FooService.java<br>package quickstart;</p>
<p>publicinterfaceFooService {<br>    public String hello(String name);<br>}<br>实现服务方逻辑。<br>src/main/java/quickstart/FooServiceImpl.java<br>package quickstart;</p>
<p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p>
<p>publicclassFooServiceImplimplementsFooService {</p>
<pre><code>public String hello(String name) {
    System.out.println(name +&quot; invoked rpc service&quot;);
    return&quot;hello &quot;+ name;
}

publicstaticvoidmain(String[] args) throws InterruptedException {
    ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&quot;classpath:motan_server.xml&quot;);
    System.out.println(&quot;server start...&quot;);
}
</code></pre><p>}<br>src/main/resources/motan_server.xml<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beansxmlns="http: www.springframework.org="" schema="" beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:motan="http://api.weibo.com/schema/motan" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd   http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd">

<pre><code>&lt;!-- service implemention bean --&gt;
&lt;beanid=&quot;serviceImpl&quot;class=&quot;quickstart.FooServiceImpl&quot; /&gt;
&lt;!-- exporting service by motan --&gt;
&lt;motan:serviceinterface=&quot;quickstart.FooService&quot;ref=&quot;serviceImpl&quot;export=&quot;8002&quot; /&gt;
</code></pre><p><br>执行FooServiceImpl类中的main函数将会启动motan服务，并监听8002端口.<br>实现服务调用方。<br>src/main/resources/motan_client.xml<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beansxmlns="http: www.springframework.org="" schema="" beans"="" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:motan="http://api.weibo.com/schema/motan" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd   http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd">

<pre><code>&lt;!-- reference to the remote service --&gt;
&lt;motan:refererid=&quot;remoteService&quot;interface=&quot;quickstart.FooService&quot;directUrl=&quot;localhost:8002&quot;/&gt;
</code></pre><p><br>src/main/java/quickstart/Client.java<br>package quickstart;</p>
<p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p>
<p>publicclassClient {</p>
<pre><code>publicstaticvoidmain(String[] args) throws InterruptedException {
    ApplicationContext ctx =new ClassPathXmlApplicationContext(&quot;classpath:motan_client.xml&quot;);
    FooService service = (FooService) ctx.getBean(&quot;remoteService&quot;);
    System.out.println(service.hello(&quot;motan&quot;));
}
</code></pre><p>}<br>执行Client类中的main函数将执行一次远程调用，并输出结果。<br>集群调用示例</p>
<p>在集群环境下使用motan需要依赖外部服务发现组件，目前支持consul或zookeeper。<br>使用Consul作为注册中心</p>
<p>Consul安装与启动</p>
<p>安装（官方文档）</p>
<h1 id="这里以linux为例"><a href="#这里以linux为例" class="headerlink" title="这里以linux为例"></a>这里以linux为例</h1><p>wget <a href="https://releases.hashicorp.com/consul/0.6.4/consul_0.6.4_linux_amd64.zip" target="_blank" rel="external">https://releases.hashicorp.com/consul/0.6.4/consul_0.6.4_linux_amd64.zip</a><br>unzip consul_0.6.4_linux_amd64.zip<br>sudo mv consul /bin<br>启动（官方文档）</p>
<p>测试环境启动：<br>consul agent -dev<br>ui后台 <a href="http://localhost:8500/ui" target="_blank" rel="external">http://localhost:8500/ui</a><br>motan-Consul配置</p>
<p>在server和client中添加motan-registry-consul依赖</p>
<p><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-registry-consul</artifactid><br>    <version>0.0.1</version><br></dependency><br>在server和client的配置文件中分别增加consul registry定义。</p>
<p><motan:registryregprotocol="consul"name="my_consul"address="127.0.0.1:8500"><br>在motan client及server配置改为通过registry服务发现。<br>client<br>    <motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_consul"><br>server<br>    <motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_consul"export="8002"><br>server程序启动后，需要显式调用心跳开关，注册到consul。<br>MotanSwitcherUtil.setSwitcher(ConsulConstants.NAMING_PROCESS_HEARTBEAT_SWITCHER, true)<br>进入ui后台查看服务是否正常提供调用<br>启动client，调用服务<br>使用ZooKeeper作为注册中心</motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_consul"export="8002"></motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_consul"></motan:registryregprotocol="consul"name="my_consul"address="127.0.0.1:8500"></p>
<p>ZooKeeper安装与启动(官方文档)</p>
<p>单机版安装与启动<br>wget <a href="http://mirrors.cnnic.cn/apache/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz" target="_blank" rel="external">http://mirrors.cnnic.cn/apache/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz</a><br>tar zxvf zookeeper-3.4.8.tar.gz</p>
<p>cd zookeeper-3.4.8/conf/<br>cp zoo_sample.cfg zoo.cfg</p>
<p>cd ../<br>sh bin/zkServer.sh start<br>motan-ZooKeeper配置</p>
<p>在server和client中添加motan-registry-zookeeper依赖</p>
<p><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-registry-zookeeper</artifactid><br>    <version>0.0.1</version><br></dependency><br>在server和client的配置文件中分别增加zookeeper registry定义。<br>zookeeper为单节点</p>
<p><motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181"><br>zookeeper多节点集群</motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181"></p>
<p><motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"><br>在motan client及server配置改为通过registry服务发现。<br>client</motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"></p>
<p><motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_zookeeper"><br>server</motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_zookeeper"></p>
<p><motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_zookeeper"export="8002"><br>启动client，调用服务</motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_zookeeper"export="8002"></p>
</beansxmlns="http:></beansxmlns="http:>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soa/">soa</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="tomcat并发优化--tomcat-Tomcat的四种基于HTTP协议的Connector性能比较" class="article article-type-tomcat并发优化--tomcat" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/Tomcat的四种基于HTTP协议的Connector性能比较/" class="article-date">
  	<time datetime="2016-04-29T00:23:26.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/Tomcat的四种基于HTTP协议的Connector性能比较/">Tomcat的四种基于HTTP协议的Connector性能比较</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tomcat 6 支持 NIO – Tomcat的四种基于HTTP协议的Connector性能比较</p>
<p>Tomcat从5.5版本开始，支持以下四种Connector的配置分别为：</p>
<!--基于NIO的http协议的Connector 性能最好--->
<connector port="8081" protocol="org.apache.coyote.http11.Http11NioProtocol" connectiontimeout="20000" redirectport="8443">

<!--tomcat默认http协议的Connector 性能最差-->
<connector port="8081" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">

<!--http连接池协议的Connector   性能差- ->   
<Connector executor="tomcatThreadPool" port="8081" protocol="HTTP/1.1"connectionTimeout="20000"redirectPort="8443" />

<!--基于NIO链接池协议的Connector 性能较好-->
<connector executor="tomcatThreadPool" port="8081" protocol="org.apache.coyote.http11.Http11NioProtocol" connectiontimeout="20000" redirectport="8443">

<p>我们姑且把上面四种Connector按照顺序命名为 NIO, HTTP, POOL, NIOP</p>
<p>为了不让其他因素影响测试结果，我们只对一个很简单的jsp页面进行测试，这个页面仅仅是输出一个Hello World。假设地址是 <a href="http://tomcat1/test.jsp" target="_blank" rel="external">http://tomcat1/test.jsp</a></p>
<p>我们依次对四种Connector进行测试，测试的客户端在另外一台机器上用ab命令来完成，测试命令为： ab -c 900 -n 2000<a href="http://tomcat1/test.jsp，最终的测试结果如下表所示(单位:平均每秒处理的请求数)：" target="_blank" rel="external">http://tomcat1/test.jsp，最终的测试结果如下表所示(单位:平均每秒处理的请求数)：</a></p>
<p>NIO    HTTP    POOL    NIOP<br>281     65     208     365<br>666     66     110     398<br>692     65     66     263<br>256     63     94     459<br>440     67     145     363</p>
<p>由这五组数据不难看出，HTTP的性能是很稳定，但是也是最差的，而这种方式就是Tomcat的默认配置。NIO方式波动很大，但没有低于280 的，NIOP是在NIO的基础上加入线程池，可能是程序处理更复杂了，因此性能不见得比NIO强；而POOL方式则波动很大，测试期间和HTTP方式一样，不时有停滞。</p>
<p>由于linux的内核默认限制了最大打开文件数目是1024，因此此次并发数控制在900。</p>
<p>尽管这一个结果在实际的网站中因为各方面因素导致，可能差别没这么大，例如受限于数据库的性能等等的问题。但对我们在部署网站应用时还是具有参考价值的。</p>
<p>这个可以利用apache server的 ab测试<br>C:\Program Files (x86)\Apache Software Foundation\Apache2.2\bin&gt;ab -n2000 -c100 <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a></p>
<p>或者</p>
<p>C:\Program Files (x86)\Apache Software Foundation\Apache2.2\bin&gt;ab -n2000 -c100 -w <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> &gt;c:/a.html</p>
<p>-n 代表请求数<br>-c 代表并发数<br>-w 输出到</p>
</connector></connector></connector>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tomcat/">tomcat</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-solr-query" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/solr-query/" class="article-date">
  	<time datetime="2016-04-29T00:22:43.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/solr-query/">solr-query</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一. Query参数 </p>
<ol>
<li><p>CoreQueryParam查询的参数<br>1) q: 查询字符串，必须的。<br>2) q.op: 覆盖schema.xml的defaultOperator（有空格时用”AND”还是用”OR”操作逻辑），一般默认指定。<br>3) df: 默认的查询字段，一般默认指定。<br>4) qt: query type，指定查询使用的Query Handler，默认为“standard”。<br>5) wt: writer type。指定查询输出结构格式，默认为“xml”。在solrconfig.xml中定义了查询输出格式：xml、json、python、ruby、php、phps、custom。<br>6) echoHandler：是否在查询结果中显示使用的Query Handler名称。<br>7) echoParams：是否显示查询参数。none：不显示；explicit：只显示查询参数；all：所有，包括在solrconfig.xml定义的Query Handler参数。<br>8) indent - 返回的结果是否缩进，默认关闭，用 indent=true|on 开启，一般调试json,php,phps,ruby输出才有必要用这个参数。<br>9) version - 查询语法的版本，建议不使用它，由服务器指定默认值。 </p>
</li>
<li><p>CommonQueryParameters<br>1) sort：排序，格式：sort=<field name="">+<desc|asc>[,<field name="">+<desc|asc>]„ 。<br>示例：（inStock desc, price asc）表示先 “inStock” 降序, 再 “price” 升序，默认是相关性降序。。<br>2) start：用于分页定义结果起始记录数，默认为0。<br>3) rows：用于分页定义结果每页返回记录数，默认为10。<br>4) fq：filter query。使用Filter Query可以充分利用Filter Query Cache，提高检索性能。作用：在q查询符合结果中同时是fq查询符合的，<br>例如：q=mm&amp;fq=date_time:[20081001 TO 20091031]，找关键字mm，并且date_time是20081001到20091031之间的。<br>5) fl：field list。指定返回结果字段。以空格“ ”或逗号“,”分隔。<br>6) debugQuery：设置返回结果是否显示Debug信息。<br>7) explainOther：设置当debugQuery=true时，显示其他的查询说明。<br>8) defType：设置查询解析器名称。<br>9) timeAllowed：设置查询超时时间。<br>10) omitHeader：设置是否忽略查询结果返回头信息，默认为“false”。 </desc|asc></field></desc|asc></field></p>
</li>
</ol>
<p>二. 查询语法 </p>
<ol>
<li>匹配所有文档：<em>:</em> </li>
<li><p>强制、阻止和可选查询：<br>1) Mandatory：查询结果中必须包括的(for example, only entry name containing the word make) Solr/Lucene Statement：+make, +make +up ,+make +up +kiss<br>2) prohibited：(for example, all documents except those with word believe) Solr/Lucene Statement：+make +up -kiss 3) optional：Solr/Lucene Statement：+make +up kiss </p>
</li>
<li><p>布尔操作：AND、OR和NOT布尔操作（必须大写）与Mandatory、optional和prohibited相似。<br>1) make AND up ＝ +make +up :AND左右两边的操作都是mandatory<br>2) make || up ＝ make OR up＝make up :OR左右两边的操作都是optional<br>3) +make +up NOT kiss ＝ +make +up –kiss<br>4) make AND up OR french AND Kiss不可以达到期望的结果，因为AND两边的操作都是mandatory的。  </p>
</li>
<li><p>子表达式查询（子查询）：可以使用“()”构造子查询。<br>For ex：(make AND up) OR (french AND Kiss) </p>
</li>
<li><p>子表达式查询中阻止查询的限制：<br>For ex:make (-up):只能取得make的查询结果；要使用make (-up <em>:</em>)查询make或者不包括up的结果。  </p>
</li>
<li>多字段fields查询：通过字段名加上分号的方式（fieldName:query）来进行查询<br>For ex：entryNm:make AND entryId:3cdc86e8e0fb4da8ab17caed42f6760c  </li>
<li>通配符查询（wildCard Query）：<br>1) 通配符？和<em>：“</em>”表示匹配任意字符；“？”表示匹配出现的位置。<br>For ex：ma?<em>（ma后面的一个位置匹配），ma??</em>(ma后面两个位置都匹配)<br>2) 查询字符必须要小写：+Ma +be<strong>可以搜索到结果；+Ma +Be</strong>没有搜索结果<br>3) 查询速度较慢，尤其是通配符在首位：主要原因一是需要迭代查询字段中的每个term，判断是否匹配；二是匹配上的term被加到内部的查询，当terms数量达到1024的时候，查询会失败。<br>4) Solr中默认通配符不能出现在首位（可以修改QueryParser，设置 setAllowLeadingWildcard为true）<br>5) set setAllowLeadingWildcard to true. </li>
<li>模糊查询、相似查询：不是精确的查询，通过对查询的字段进行重新插入、删除和转换来取得得分较高的查询解决（由Levenstein Distance Algorithm算法支持）。<br>1) 一般模糊查询：for ex：make-believ~<br>2) 门槛模糊查询：对模糊查询可以设置查询门槛，门槛是0~1之间的数值，门槛<br>越高表面相似度越高。For ex：make-believ~0.5、make-believ~0.8、make-believ~0.9  </li>
<li><p>范围查询（Range Query）：Lucene支持对数字、日期甚至文本的范围查询。结束的范围可以使用“<em>”通配符。<br>For ex：<br>1) 日期范围（ISO-8601 时间GMT）：sa_type:2 AND a_begin_date:[1990-01-01T00:00:00.000Z TO 1999-12-31T24:59:99.999Z]<br>2) 数字：salary:[2000 TO </em>] 3) 文本：entryNm:[a TO a] </p>
</li>
<li><p>日期匹配：YEAR, MONTH, DAY, DATE (synonymous with DAY) HOUR, MINUTE, SECOND, MILLISECOND, and MILLI (synonymous with MILLISECOND)可以被标志成日期。<br>For ex：<br>1) r_event_date:[<em> TO NOW-2YEAR]：2年前的现在这个时间<br>2) r_event_date:[</em> TO NOW/DAY-2YEAR]：2年前前一天的这个时间 </p>
</li>
</ol>
<p>三. 函数查询（Function Query）<br>函数查询 可以利用 numeric域的值 或者 与域相关的的某个特定的值的函数，来对文档进行评分。 </p>
<ol>
<li><p>使用函数查询的方法<br>这里主要有三种方法可以使用函数查询，这三种s方法都是通过solr http接口的。<br>1) 使用FunctionQParserPlugin。ie: q={!func}log(foo)<br>2) 使用“<em>val</em>”内嵌方法内嵌在正常的solr查询表达式中。即，将函数查询写在 q这个参数中，这时候，我们使用“<em>val</em>”将函数与其他的查询加以区别。 ie：entryNm:make &amp;&amp; <em>val</em>:ord(entryNm)<br>3) 使用dismax中的bf参数使用明确为函数查询的参数，比如说dismax中的bf（boost function）这个参数。  注意：bf这个参数是可以接受多个函数查询的，它们之间用空格隔开，它们还可以带上权重。所以，当我们使用bf这个参数的时候，我们必须保证单个函数中是没有空格出现的，不然程序有可能会以为是两个函数。<br>For ex：<br>q=dismax&amp;bf=”ord(popularity)^0.5 recip(rord(price),1,1000,1000)^0.3   2. 函数的格式（Function Query Syntax) 目前，function query 并不支持 a+b 这样的形式，我们得把它写成一个方法形式，这就是 sum(a,b). </p>
</li>
<li><p>使用函数查询注意事项<br>1) 用于函数查询的field必须是被索引的；<br>2) 字段不可以是多值的（multi-value） </p>
</li>
<li><p>可以利用的函数 （available function）<br>1) constant：支持有小数点的常量； 例如：1.5 ；SolrQuerySyntax:<em>val</em>:1.5<br>2) fieldvalue：这个函数将会返回numeric field的值，这个域必须是indexd的，非multiValued的。格式很简单，就是该域的名字。如果这个域中没有这样的值，那么将会返回0。<br>3) ord：对于一个域，它所有的值都将会按照字典顺序排列，这个函数返回你要查询的那个特定的值在这个顺序中的排名。这个域，必须是非multiValued的，当没有值存在的时候，将返回0。例如：某个特定的域只能去三个值，“apple”、“banana”、“pear”，那么ord（“apple”）=1，ord（“banana”）=2，ord（“pear”）=3.需要注意的是，ord（）这个函数，依赖于值在索引中的位置，所以当有文档被删除、或者添加的时候，ord（）的值就会发生变化。当你使用MultiSearcher的时候，这个值也就是不定的了。<br>4) rord：这个函数将会返回与ord相对应的倒排序的排名。 格式: rord(myIndexedField)。<br>5) sum：这个函数的意思就显而易见啦，它就是表示“和”啦。格式：sum(x,1) 、sum(x,y)、 sum(sqrt(x),log(y),z,0.5)<br>6) product：product(x,y,…)将会返回多个函数的乘积。格式：product(x,2)、product(x,y)<br>7) div：div(x,y)表示x除以y的值，格式：div（1,x）、div(sum(x,100),max(y,1))<br>8) pow：pow表示幂值。pow(x,y) =x^y。例如：pow(x,0.5) 表示开方pow(x,log(y))<br>9) abs：abs(x)将返回表达式的绝对值。格式：abs(-5)、 abs(x)<br>10)  log：log(x)将会返回基数为10，x的对数。格式： log(x)、 log(sum(x,100))<br>11)  Sqrt：sqrt(x) 返回 一个数的平方根。格式：sqrt（2）、sqrt(sum(x,100))<br>12)  Map：如果 x&gt;=min,且x&lt;=max,那么map(x,min,max,target)=target.如果 x不在[min,max]这个区间内，那么map(x,min,max,target)=x.  格式：map(x,0,0,1)<br>13) Scale：scale(x,minTarget,maxTarget) 这个函数将会把x的值限制在[minTarget,maxTarget]范围内。 14) query ：query(subquery,default)将会返回给定subquery的分数，如果subquery与文档不匹配，那么将会返回默认值。任何的查询类型都是受支持的。可以通过引用的方式，也可以直接指定查询串。<br>例子：q=product(popularity, query({!dismax v=’solr rocks’}) 将会返回popularity和通过dismax 查询得到的分数的乘积。<br>q=product(popularity, query($qq)&amp;qq={!dismax}solr rocks 跟上一个例子的效果是一样的。不过这里使用的是引用的方式<br>q=product(popularity, query($qq,0.1)&amp;qq={!dismax}solr rocks 在前一个例子的基础上又加了一个默认值。<br>15)  linear： inear(x,m,c)表示 m<em>x+c ,其中m和c都是常量，x是一个变量也可以是一个函数。例如： linear(x,2,4)=2</em>x+4.<br>16) Recip：recip(x,m,a,b)=a/(m*x+b)其中，m、a、b是常量，x是变量或者一个函数。当a=b，并且x&gt;=0的时候，这个函数的最大值是1，值的大小随着x的增大而减小。例如：recip(rord(creationDate),1,1000,1000)<br>17) Max： max(x,c)将会返回一个函数和一个常量之间的最大值。 例如：max(myfield,0)</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/solr/">solr</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mysql跨数据库操作类似与oracle的dblink" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/mysql跨数据库操作类似与oracle的dblink/" class="article-date">
  	<time datetime="2016-04-29T00:21:31.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/mysql跨数据库操作类似与oracle的dblink/">mysql跨数据库操作类似与oracle的dblink</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MySQL FEDERATED 存储引擎</p>
<pre><code>MySQL中针对不同的功能需求提供了不同的存储引擎。所谓的存储引擎也就是MySQL下特定接口的具体实现。
FEDERATED是其中一个专门针对远程数据库的实现。一般情况下在本地数据库中建表会在数据库目录中生成相应的表定义文件，并同时生成相应的数据文件。
</code></pre><p>但通过FEDERATED引擎创建的表只是在本地有表定义文件，数据文件则存在于远程数据库中(这一点很重要)。<br>             通过这个引擎可以实现类似Oracle 下DBLINK的远程数据访问功能。<br>             使用show engines 命令查看数据库是否已支持FEDERATED引擎：</p>
<pre><code>Support 的值有以下几个：
</code></pre><p>YES    支持并开启<br>DEFAULT    支持并开启, 并且为默认引擎<br>NO    不支持<br>DISABLED    支持,但未开启</p>
<p>可以看出MyISAM为当前默认的引擎。<br>                使用FEDERATED建表语句如下：<br>                CREATE TABLE (……) ENGINE =FEDERATED CONNECTION=’mysql://[name]:[pass]@[location]:[port]/[db-name]/[table-name]’<br>               创建成功后就可直接在本地查询相应的远程表了。<br>需要注意的几点：</p>
<pre><code>1. 本地的表结构必须与远程的完全一样。
2.远程数据库目前仅限MySQL
3.不支持事务
4.不支持表结构修改
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle/">oracle</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-github搭建个人博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/hexo-github搭建个人博客/" class="article-date">
  	<time datetime="2016-04-29T00:20:21.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/hexo-github搭建个人博客/">hexo+github搭建个人博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>hexo+github搭建个人博客</p>
<p>字数841 阅读543 评论12 喜欢18<br>现在一个程序猿（媛）没有一个自己的博客都不好意思说自己是程序员，哈哈开玩笑的。是否有一个方法，可以让我们自己创建一个属于自己的博客，然后又不用花钱买服务器和域名，也不用自己找人去设计自己的网站呢。<br>这样的好东西还真的存在，而且配置还十分简单，下面我就详细的介绍如何用hexo+github搭建自己的（酷炫）博客。<br>前期准备</p>
<p>node.js<br>如果你是windows,请戳这里<br>如果你是mac,请戳这里<br>git账号<br>如果没有git帐号，请戳这里<br>安装hexo<br>npm install -g hexo<br>初始化hexo<br>hexo init<br>npm install hexo –save<br>生成静态页面至hexo\public\目录。<br>hexo g<br>本地启动服务<br>hexo server<br>这样，我们就可以在浏览器中输入<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 访问我们的博客啦（响应式的网站）。</p>
<p>初始界面-PC.png</p>
<p>初始界面-移动端.png<br>虽然博客基本的已经搭好了，但是我们只能在本地访问，其他人是看不到的，下面我们通过和git绑定来实现我们想要的效果。</p>
<p>配置github<br>新建一个仓库名（该仓库名和你的用户名对应），如我的git账户名是：coder-Yin，则我的仓库名为coder-Yin.github.io<br>编辑_config.yml文件，建立与git的关联(在.yml文件的最底部)</p>
<h1 id="Deployment-Docs-http-hexo-io-docs-deployment-html"><a href="#Deployment-Docs-http-hexo-io-docs-deployment-html" class="headerlink" title="Deployment## Docs: http://hexo.io/docs/deployment.html"></a>Deployment## Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">http://hexo.io/docs/deployment.html</a></h1><p>deploy:<br>  type: git<br>  repository: <a href="https://github.com/coder-Yin/coder-Yin.github.io.git" target="_blank" rel="external">https://github.com/coder-Yin/coder-Yin.github.io.git</a><br>  branch: master<br>然后运行<br>npm install hexo-deployer-git –save<br>hexo g<br>hexo d<br>这样你就可以在你的 coder-Yin.github.io 上看到代码已经同步到git上了。<br>在浏览器中输入你的**.github..io(例如：<a href="http://coder-yin.github.io/）" target="_blank" rel="external">http://coder-yin.github.io/）</a></p>
<p>访问效果.png<br>每次有新的修改需要部署同步，都可以按照下面的步骤来：<br>hexo clean<br>hexo g<br>hexo d<br>如果你觉得hexo默认的主题不好看，你可以通过以下方法来修改你的主题。</p>
<p>下面我通过修改一个主题来给大家做个介绍：<br>在git上找到你想要的主题<br>我这随意找了一个，比较适合女孩子（缺点:不是自适应的）<br><a href="https://github.com/daisygao/hexo-themes-cover" target="_blank" rel="external">https://github.com/daisygao/hexo-themes-cover</a><br>进入你的hexo目录，执行命令，拷贝主题<br>git clone <a href="https://github.com/daisygao/hexo-themes-cover.git" target="_blank" rel="external">https://github.com/daisygao/hexo-themes-cover.git</a> themes/cover<br>拷贝完成后，你会发现你的项目下的themes下多了一个cover文件夹<br>我们还需要修改_config.yml文件中的一处来应用新的主题</p>
<h1 id="Extensions-Plugins-http-hexo-io-plugins-Themes-http-hexo-io-themes"><a href="#Extensions-Plugins-http-hexo-io-plugins-Themes-http-hexo-io-themes" class="headerlink" title="Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/"></a>Extensions## Plugins: <a href="http://hexo.io/plugins/##" target="_blank" rel="external">http://hexo.io/plugins/##</a> Themes: <a href="http://hexo.io/themes/" target="_blank" rel="external">http://hexo.io/themes/</a></h1><p>theme: cover<br>然后我们重启服务就可以在本地看到效果了<br>hexo server</p>
<p>hexo应用新的主题.png</p>
<p>注意：我们这样只是本地做了修改，git上并没有实现同步，我们需要按照上面所说的，依次执行以下命令实现部署同步：<br>hexo clean<br>hexo g<br>hexo d<br>在刷新你的<a href="http://***.github.io/" target="_blank" rel="external">http://***.github.io/</a> 就可以发现新的主题应用成功了，是不是很简单，快动手建立你自己的博客吧。<br>最后，附上更多的hexo主题，大家可以很戳这里选择你自己喜好的主题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 菜菜
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>