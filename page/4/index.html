<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>菜菜的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="菜菜的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="菜菜的博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="菜菜的博客">
<meta property="og:description" content="菜菜的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="菜菜的博客">
<meta name="twitter:description" content="菜菜的博客">
  
    <link rel="alternative" href="/atom.xml" title="菜菜的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">菜菜</a></h1>
		</hgroup>

		
		<p class="header-subtitle">菜菜的博客</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags">标签</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/memcached/" style="font-size: 10px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/soa/" style="font-size: 16.67px;">soa</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.didispace.com">程序猿DD</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">菜菜</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">菜菜</h1>
			</hgroup>
			
			<p class="header-subtitle">菜菜的博客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">标签</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Venus-唯品会分布式框架" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/Venus-唯品会分布式框架/" class="article-date">
  	<time datetime="2016-04-28T09:25:23.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/Venus-唯品会分布式框架/">Venus----唯品会分布式框架</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://wiki.hexnova.com/display/Venus/HOME" target="_blank" rel="external">http://wiki.hexnova.com/display/Venus/HOME</a></p>
<p> HOME</p>
<p>附件：1<br>被Struct添加，被Struct最后更新于2015-Aug-26  (查看更改)<br>Venus（New Version：3.2.14） 是什么？</p>
<p>它是由(Venus service framework)+服务路由产品（Venus-Bus）+服务注册中心(Venus-Registry) 组合而成，提供远程服务。它着 开发简单、高性能、高并发能力 的服务端框架。<br>客户端与服务端之间的通讯对开发人员完全透明<br>他跟目前我们经常用到的框架：axis、CXF、Hessian WebService、Jboss Remoting等框架类似。<br>系统功能目标：<br>提供高性能的服务通讯框架<br>具备性能监控（可以清晰的看到每个服务执行的时间、过长可以通过监控告警出去）<br>具备流量控制（每个服务每个时刻的调用次数、每天的峰值情况、）<br>访问控制（服务的授权控制）<br>提供可选择性服务数据缓存（cache支持，key采用表达式，由框架提供缓存支持，而不需要编写任何cache相关的代码）<br>提供框架进行再次研发能力，提供interceptor、validator等接口。<br>提供高性能的服务总线（Venus-Bus），能够轻易接入高性能的服务总线。（Venus-Bus项目支持，针对该venus的协议，以后接入服务总线轻而易举）<br>开发方面：<br>服务接口定义清晰(接口、参数、校验、以及服务鉴权)<br>自动生成接口文档，以方便阅读接口声明<br>客户端框架快速开发、提供多种语言版本的客户端<br>提供3种服务调用方式（同步、异步、回调）<br>服务端框架提供多种协议提供服务，而不需要做额外的开发<br>    语言支持情况<br>目前客户端SDK暂时只有java、PHP语言版本<br>服务端面向java语言<br>java 语言开发例子<br>演讲稿下载</p>
<p>Venus演讲稿.pdf<br>开发人员的关注点</p>
<ol>
<li>如何服务化</li>
</ol>
<p>采用接口与实现分离，服务接口是一种契约，他与我们开发web Service类似。<br>java开发语言：采用对程序员友好的接口申明形式，开发人员不需要关心客户端与服务端之间的传输协议。<br>其他语言：可以通过该框架提供自定义协议或者Http协议（http协议即将在2.1.0版本release出来）进行交互</p>
<ol>
<li>服务接口定制</li>
</ol>
<p>定义服务接口<br>接口参数命名<br>定义参数校验规则<br>Java语言服务接口尽量不要依赖其他项目. 接口层面只需要接口相关的参数对象类与服务类<br>异常定义</p>
<ol>
<li><p>接口参数校验</p>
</li>
<li><p>提供3种交互方式</p>
<p>请求应答模式：普通的request、response，一般用于接口有返回值<br>异步请求模式：通常用于接口无返回值，客户端并不关心服务器的处理结果，也不用关心服务器处理多少时间<br>异步回调模式：接口无返回值，处理通常消化大量时间，需要服务端通知处理结果的业务接口<br>源代码：</p>
</li>
</ol>
<p>demo 的svn 地址：svn://svn.hexnova.com/venus/venus-helloworld/trunk<br>框架svn地址： svn://svn.hexnova.com/venus/venus-framework/trunk<br>svn的用户名：guest<br>svn密码：guest<br>Maven Repository</p>
<p><repository><id>hexnova-open</id><url><a href="http://maven.hexnova.com/nexus/content/groups/hexnova-open" target="_blank" rel="external">http://maven.hexnova.com/nexus/content/groups/hexnova-open</a></url><releases><enabled>true</enabled><updatepolicy>never</updatepolicy></releases><snapshots><enabled>true</enabled><updatepolicy>always</updatepolicy></snapshots></repository><br>目前版本情况：</p>
<p>trunk是最新开发版本，会不停有新东西进入<br>稳定版本: 3.2.14<br>最新版本:3.2.14<br>版本发布Blog地址： <a href="http://wiki.hexnova.com/pages/viewrecentblogposts.action?key=Venus" target="_blank" rel="external">http://wiki.hexnova.com/pages/viewrecentblogposts.action?key=Venus</a><br>开发人员与blog</p>
<p>日志</p>
<p>日志: Venus 3.2.12 Release 创建：<br>Struct<br>2014-Sep-05<br>Venus<br>日志: Venus 3.2.10 Release 创建：<br>Struct<br>2014-Jun-25<br>Venus<br>日志: Venus 3.2.3 Released 创建：<br>Struct<br>2014-Feb-19<br>Venus<br>日志: Venus 3.0.9 Released 创建：<br>Struct<br>2013-Dec-25<br>Venus<br>日志: Venus 3.0.6 Released 创建：<br>Struct<br>2013-Nov-22<br>Venus<br>日志: Venus 3.0.4 Released 创建：<br>Struct<br>2013-Nov-14<br>Venus<br>日志: Venus 3.0.3 Released 创建：<br>Struct<br>2013-Oct-25<br>Venus<br>日志: Venus 3.0.2 Released 创建：<br>Struct<br>2013-Oct-21<br>Venus<br>日志: Venus 3.0.1 Released 创建：<br>Struct<br>2013-Oct-14<br>Venus<br>日志: Venus 2.3.0 Released 创建：<br>Struct<br>2012-Oct-08<br>Venus<br>日志: Venus 2.2.7 Released 创建：<br>Struct<br>2012-Sep-24<br>Venus<br>日志: Venus 2.2.6 Released 创建：<br>Struct<br>2012-Jun-28<br>Venus<br>日志: Venus 2.2.3 Released 创建：<br>Struct<br>2012-May-21<br>Venus<br>日志: Venus 2.0.4 Released 创建：<br>Struct<br>2012-Mar-31<br>Venus<br>日志: Venus 2.0.3 Released 创建：<br>Struct<br>2012-Mar-23<br>Venus<br>日志: Venus 2.0.1 Released 创建：<br>Struct<br>2012-Jan-02<br>Venus<br>日志: Venus 1.3.0 Released 创建：<br>Struct<br>2011-Dec-07<br>Venus<br>日志: Venus 1.2.0 Released 创建：<br>Struct<br>2011-Dec-01<br>Venus<br>日志: Venus 1.1.0 Released 创建：<br>Struct<br>2011-Nov-28<br>Venus</p>
<p>研发人员列表</p>
<p>昵称    角色    职责    开源社区    目前供职于<br>Struct    Member    负责架构设计、通信框架研发、服务框架研发    Hexnova    上海汽车工业集团<br>Daisy    Member    对象数据序列化、服务接口数据校验、服务框架研发    Hexnova    </p>
<p>Sunng    Member    服务框架研发    Hexnova    </p>
<p>Yuanjian Yi    Member<br>PHP客户端开发    Hexnova<br>上海由你网络科技有限公司<br>huawei    Member<br>服务注册中心    Hexnova </p>
<p>样例：</p>
<p>简单的接口例子：HelloService.java<br>HelloService接口例子<br>package com.meidusa.venus.hello.api;</p>
<p>import com.meidusa.venus.annotations.Endpoint;<br>import com.meidusa.venus.annotations.Param;<br>import com.meidusa.venus.annotations.Service;<br>import com.meidusa.venus.notify.InvocationListener;</p>
<p>/**</p>
<ul>
<li>Service framework的 HelloService 接口例子.<p></p></li>
<li>支持3种调用方式：<p></p></li>
<li></li><li> 请求应答模式：普通的request、response，一般用于接口有返回值</li>
<li></li><li> 异步请求模式：通常用于接口无返回值，客户端并不关心服务器的处理结果，也不用关心服务器处理多少时间</li>
<li></li><li> 异步回调模式：接口无返回值，处理通常消化大量时间，需要服务端通知处理结果的业务接口</li><br>*
<li><p>@author Struct<br><em>
</em>/<br>@Service(name=”HelloService”,version=1)<br>publicinterface HelloService {</p>
<p> /**</p>
<ul>
<li>无返回结果的服务调用，支持回调方式，该服务在通讯层面上为异步调用</li>
<li>@param name</li>
<li>@param invocationListener 客户端的回调接口<br>*/<br>@Endpoint(name=”sayHelloWithCallbak”)<br>publicabstract void sayHello(@Param(name=”name”) String name,<pre><code>@Param(name=&quot;callback&quot;) InvocationListener&lt;Hello&gt; invocationListener);
</code></pre>/**</li>
<li>无返回结果的服务调用，支持同步或者异步调用,</li>
<li>该接口申明：同步，并且接口申明异常</li>
<li><p>@param name<br>*/<br>@Endpoint(name=”sayHello”,async=false)<br>publicabstract void sayHello(@Param(name=”name”) String name) throws HelloNotFoundException;</p>
<p>/**</p>
</li>
<li>无返回结果的服务调用，支持同步或者异步调用，无异常申明</li>
<li>@param name<br>*/<br>@Endpoint(name=”sayAsyncHello”,async=true)<br>publicabstract void sayAsyncHello(@Param(name=”name”) String name);</li>
</ul>
</li>
</ul>
<pre><code>/**
 * 有返回结果的服务调用，该接口只能支持同步调用
 * @param name
 * @return
 */
@Endpoint(name=&quot;getHello&quot;,timeWait=10000)
publicabstract Hello getHello(@Param(name=&quot;name&quot;) String name);
</code></pre><p>}<br>客户端TestCase编写<br>客户端TestCase<br>package com.meidusa.venus.hello.client;</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<p>import org.junit.Test;<br>import org.junit.runner.RunWith;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.test.context.ContextConfiguration;<br>import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</p>
<p>import com.meidusa.venus.exception.CodedException;<br>import com.meidusa.venus.hello.api.Hello;<br>import com.meidusa.venus.hello.api.HelloNotFoundException;<br>import com.meidusa.venus.hello.api.HelloService;<br>import com.meidusa.venus.notify.InvocationListener;</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(locations=”classpath:/applicationContext-helloworld-client.xml”)<br>public class TestHelloService {</p>
<pre><code>@Autowired
private HelloService helloService;

@Test
public void saySync(){
    System.out.println(helloService.getHello(&quot;jack&quot;));
}

@Test
public void testSyncWithException(){
    try {
        helloService.sayHello(&quot;jack&quot;);
    } catch (HelloNotFoundException e) {
        System.out.println(&quot;throw an user defined HelloNotFoundException&quot;);
    }
}

@Test
public void testAsync(){
    helloService.sayAsyncHello(&quot;jack&quot;);
}

@Test
public void testCallback() throws Exception{
    //为了让回调完成，采用countDownLatch计数器方式，避免testcase主线程运行完成而回调未结束的问题
</code></pre><p>final CountDownLatch latch = new CountDownLatch(1);</p>
<pre><code>              //在正常的使用的代码中这个类需要单实例，避免过多的callback listener导致内存问题
                  InvocationListener&lt;Hello&gt; listener = new InvocationListener&lt;Hello&gt;() {
        public void callback(Hello myobject) {
            System.out.println(&quot; async call back result=&quot;+myobject);
            latch.countDown();
        }

        @Override
        public void onException(Exception e) {
            if(e instanceof CodedException){
                CodedException exception = (CodedException) e;
                System.out.println(&quot; async call back error:&quot;+exception.getErrorCode()+&quot;,message=&quot;+exception.getMessage());
            }else{
                System.out.println(&quot; async call back message=&quot;+e.getMessage());
            }
            latch.countDown();

        }
    };

    helloService.sayHello(&quot;jack&quot;,listener);
    latch.await();
}
</code></pre><p>}<br>服务端的实现<br>服务端对HelloService的简单实现<br>package com.meidusa.venus.hello.impl;</p>
<p>import java.math.BigDecimal;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>import com.meidusa.venus.hello.api.Hello;<br>import com.meidusa.venus.hello.api.HelloNotFoundException;<br>import com.meidusa.venus.hello.api.HelloService;<br>import com.meidusa.venus.notify.InvocationListener;</p>
<p>public class DefaultHelloService implements HelloService {<br>    privateString greeting;<br>    publicString getGreeting() {<br>        return greeting;<br>    }</p>
<pre><code>public void setGreeting(String greeting) {
    this.greeting = greeting;
}
public Hello getHello(String name) {
    Hello hello = new Hello();
    hello.setName(name);
    hello.setGreeting(greeting);
    Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
    hello.setMap(map);
    map.put(&quot;1&quot;, 1);
    map.put(&quot;2&quot;, newLong(2));
    map.put(&quot;3&quot;, newInteger(3));
    hello.setBigDecimal(new BigDecimal(&quot;1.341241233412&quot;));
    return hello;
}

public void sayHello(String name)  throws HelloNotFoundException {
    thrownew HelloNotFoundException(name +&quot; not found&quot;);
}

@Override
public void sayAsyncHello(String name) {
    System.out.println(&quot;method sayAsyncHello invoked&quot;);
}

public void sayHello(String name,
        InvocationListener&lt;Hello&gt; invocationListener) {
    Hello hello = new Hello();
    hello.setName(name);
    hello.setGreeting(greeting);
    Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
    hello.setMap(map);
    map.put(&quot;1&quot;, 1);
    map.put(&quot;2&quot;, newLong(2));
    map.put(&quot;3&quot;, newInteger(3));

    if(invocationListener != null){
        invocationListener.callback(hello);
    }

}
</code></pre><p>}<br>最近的更新</p>
<p>Go语言客户端 go-venus-plugin<br>commented by deephex<br>Jan 22<br>Go语言客户端 go-venus-plugin<br>updated by Struct<br>(view change)<br>Jan 15</p>
<ol>
<li>各种客户端简单使用<br>updated by Struct<br>(view change)<br>Jan 15<br>go-venus-plugin.zip<br>attached by Struct<br>Jan 15<br>go-venus-plugin.zip<br>attached by Struct<br>Jan 15<br>JAVA语言客户端<br>commented by 匿名用户<br>2015-Oct-14<br>HOME<br>commented by wangzhenjun<br>2015-Oct-08<br>HOME<br>updated by Struct<br>(view change)<br>2015-Aug-26<br>JAVA语言客户端<br>commented by 匿名用户<br>2015-Aug-10<br>后端处理线程设置<br>updated by Struct<br>(view change)<br>2015-Jul-29<br>. Venus Http协议<br>updated by Struct<br>(view change)<br>2015-Jun-29<br>venus-http-adaptor-3.2.13-distribution.zip<br>attached by Struct<br>2015-Jun-29<br>JAVA语言客户端<br>updated by Struct<br>(view change)<br>2015-Jun-11<br>HOME<br>commented by zhuo<br>2015-Feb-14<br>Venus 3.2.12 Release<br>commented by sunstar_s<br>2015-Jan-14<br>Venus Eclipse Plugin发布<br>commented by 匿名用户<br>2015-Jan-10<br>Venus Eclipse Plugin发布<br>commented by 匿名用户<br>2015-Jan-05<br>HOME<br>commented by 匿名用户<br>2014-Nov-06<br>HOME<br>commented by 匿名用户<br>2014-Nov-05<br>Venus 3.2.12 Release<br>created by Struct<br>2014-Sep-05<br>More </li>
</ol>
<p>Navigate space</p>
<ol>
<li>各种客户端简单使用</li>
<li>高级使用指南</li>
<li>Architecture</li>
<li>协议以及交互序列图介绍</li>
<li>性能测试工具–Service-benchmark</li>
<li>性能测试(单客户端)</li>
<li><p>极限测试(多客户端)<br>FAQ<br>Venus Eclipse Plugin发布<br>二、其他语言客户端<br>子页面 (10) </p>
<p>隐藏子页面  |  页面重排<br>页面: 1. 各种客户端简单使用<br>页面: 2. 高级使用指南<br>页面: 3. Architecture<br>页面: 4. 协议以及交互序列图介绍<br>页面: 5. 性能测试工具–Service-benchmark<br>页面: 6. 性能测试(单客户端)<br>页面: 7. 极限测试(多客户端)<br>页面: FAQ<br>页面: Venus Eclipse Plugin发布<br>页面: 二、其他语言客户端 </p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soa/">soa</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-新浪开源分布式框架-motan" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/新浪开源分布式框架-motan/" class="article-date">
  	<time datetime="2016-04-28T09:24:27.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/新浪开源分布式框架-motan/">新浪开源分布式框架--motan</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开源地址 <a href="https://github.com/weibocom/motan/wiki/zh_quickstart" target="_blank" rel="external">https://github.com/weibocom/motan/wiki/zh_quickstart</a></p>
<p>zh_quickstart</p>
<p>axb edited this page 2 days ago · 2 revisions<br> Pages 8</p>
<p>Documents</p>
<p>Overview<br>Quick Start<br>User Guide(Preparing)<br>Develop Guide(Preparing)<br>FAQ<br>中文文档</p>
<p>概述<br>快速入门<br>用户指南<br>开发指南(准备中)<br>常见问题<br>Clone this wiki locally</p>
<p> Clone in Desktop<br>快速入门<br>简单调用示例<br>集群调用示例<br>使用Consul作为注册中心<br>使用ZooKeeper作为注册中心<br>快速入门中会给出一些基本使用场景下的配置方式，更详细的使用文档请参考用户指南.<br>如果要执行快速入门介绍中的例子，你需要:<br>JDK 1.7或更高版本。<br>java依赖管理工具，如Maven或Gradle。<br>简单调用示例</p>
<p>在pom中增加依赖</p>
<dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-core</artifactid><br>    <version>0.0.1</version><br></dependency><br><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-transport-netty</artifactid><br>    <version>0.0.1</version><br></dependency>

<!-- only needed for spring-based features -->
<p><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-springsupport</artifactid><br>    <version>0.0.1</version><br></dependency></p>
<p><dependency><br>    <groupid>org.springframework</groupid><br>    <artifactid>spring-context</artifactid><br>    <version>4.2.4.RELEASE</version><br></dependency><br>为调用方和服务方创建接口。<br>src/main/java/quickstart/FooService.java<br>package quickstart;</p>
<p>publicinterfaceFooService {<br>    public String hello(String name);<br>}<br>实现服务方逻辑。<br>src/main/java/quickstart/FooServiceImpl.java<br>package quickstart;</p>
<p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p>
<p>publicclassFooServiceImplimplementsFooService {</p>
<pre><code>public String hello(String name) {
    System.out.println(name +&quot; invoked rpc service&quot;);
    return&quot;hello &quot;+ name;
}

publicstaticvoidmain(String[] args) throws InterruptedException {
    ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&quot;classpath:motan_server.xml&quot;);
    System.out.println(&quot;server start...&quot;);
}
</code></pre><p>}<br>src/main/resources/motan_server.xml<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beansxmlns="http: www.springframework.org="" schema="" beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:motan="http://api.weibo.com/schema/motan" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd   http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd">

<pre><code>&lt;!-- service implemention bean --&gt;
&lt;beanid=&quot;serviceImpl&quot;class=&quot;quickstart.FooServiceImpl&quot; /&gt;
&lt;!-- exporting service by motan --&gt;
&lt;motan:serviceinterface=&quot;quickstart.FooService&quot;ref=&quot;serviceImpl&quot;export=&quot;8002&quot; /&gt;
</code></pre><p><br>执行FooServiceImpl类中的main函数将会启动motan服务，并监听8002端口.<br>实现服务调用方。<br>src/main/resources/motan_client.xml<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beansxmlns="http: www.springframework.org="" schema="" beans"="" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:motan="http://api.weibo.com/schema/motan" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd   http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd">

<pre><code>&lt;!-- reference to the remote service --&gt;
&lt;motan:refererid=&quot;remoteService&quot;interface=&quot;quickstart.FooService&quot;directUrl=&quot;localhost:8002&quot;/&gt;
</code></pre><p><br>src/main/java/quickstart/Client.java<br>package quickstart;</p>
<p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p>
<p>publicclassClient {</p>
<pre><code>publicstaticvoidmain(String[] args) throws InterruptedException {
    ApplicationContext ctx =new ClassPathXmlApplicationContext(&quot;classpath:motan_client.xml&quot;);
    FooService service = (FooService) ctx.getBean(&quot;remoteService&quot;);
    System.out.println(service.hello(&quot;motan&quot;));
}
</code></pre><p>}<br>执行Client类中的main函数将执行一次远程调用，并输出结果。<br>集群调用示例</p>
<p>在集群环境下使用motan需要依赖外部服务发现组件，目前支持consul或zookeeper。<br>使用Consul作为注册中心</p>
<p>Consul安装与启动</p>
<p>安装（官方文档）</p>
<h1 id="这里以linux为例"><a href="#这里以linux为例" class="headerlink" title="这里以linux为例"></a>这里以linux为例</h1><p>wget <a href="https://releases.hashicorp.com/consul/0.6.4/consul_0.6.4_linux_amd64.zip" target="_blank" rel="external">https://releases.hashicorp.com/consul/0.6.4/consul_0.6.4_linux_amd64.zip</a><br>unzip consul_0.6.4_linux_amd64.zip<br>sudo mv consul /bin<br>启动（官方文档）</p>
<p>测试环境启动：<br>consul agent -dev<br>ui后台 <a href="http://localhost:8500/ui" target="_blank" rel="external">http://localhost:8500/ui</a><br>motan-Consul配置</p>
<p>在server和client中添加motan-registry-consul依赖</p>
<p><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-registry-consul</artifactid><br>    <version>0.0.1</version><br></dependency><br>在server和client的配置文件中分别增加consul registry定义。</p>
<p><motan:registryregprotocol="consul"name="my_consul"address="127.0.0.1:8500"><br>在motan client及server配置改为通过registry服务发现。<br>client<br>    <motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_consul"><br>server<br>    <motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_consul"export="8002"><br>server程序启动后，需要显式调用心跳开关，注册到consul。<br>MotanSwitcherUtil.setSwitcher(ConsulConstants.NAMING_PROCESS_HEARTBEAT_SWITCHER, true)<br>进入ui后台查看服务是否正常提供调用<br>启动client，调用服务<br>使用ZooKeeper作为注册中心</motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_consul"export="8002"></motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_consul"></motan:registryregprotocol="consul"name="my_consul"address="127.0.0.1:8500"></p>
<p>ZooKeeper安装与启动(官方文档)</p>
<p>单机版安装与启动<br>wget <a href="http://mirrors.cnnic.cn/apache/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz" target="_blank" rel="external">http://mirrors.cnnic.cn/apache/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz</a><br>tar zxvf zookeeper-3.4.8.tar.gz</p>
<p>cd zookeeper-3.4.8/conf/<br>cp zoo_sample.cfg zoo.cfg</p>
<p>cd ../<br>sh bin/zkServer.sh start<br>motan-ZooKeeper配置</p>
<p>在server和client中添加motan-registry-zookeeper依赖</p>
<p><dependency><br>    <groupid>com.weibo</groupid><br>    <artifactid>motan-registry-zookeeper</artifactid><br>    <version>0.0.1</version><br></dependency><br>在server和client的配置文件中分别增加zookeeper registry定义。<br>zookeeper为单节点</p>
<p><motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181"><br>zookeeper多节点集群</motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181"></p>
<p><motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"><br>在motan client及server配置改为通过registry服务发现。<br>client</motan:registryregprotocol="zookeeper"name="my_zookeeper"address="127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"></p>
<p><motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_zookeeper"><br>server</motan:refererid="remoteservice"interface="quickstart.fooservice"registry="my_zookeeper"></p>
<p><motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_zookeeper"export="8002"><br>启动client，调用服务</motan:serviceinterface="quickstart.fooservice"ref="serviceimpl"registry="my_zookeeper"export="8002"></p>
</beansxmlns="http:></beansxmlns="http:>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soa/">soa</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Tomcat的四种基于HTTP协议的Connector性能比较" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/Tomcat的四种基于HTTP协议的Connector性能比较/" class="article-date">
  	<time datetime="2016-04-28T09:23:26.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/Tomcat的四种基于HTTP协议的Connector性能比较/">Tomcat的四种基于HTTP协议的Connector性能比较</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tomcat 6 支持 NIO – Tomcat的四种基于HTTP协议的Connector性能比较</p>
<p>Tomcat从5.5版本开始，支持以下四种Connector的配置分别为：</p>
<!--基于NIO的http协议的Connector 性能最好--->
<connector port="8081" protocol="org.apache.coyote.http11.Http11NioProtocol" connectiontimeout="20000" redirectport="8443">

<!--tomcat默认http协议的Connector 性能最差-->
<connector port="8081" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">

<!--http连接池协议的Connector   性能差- ->   
<Connector executor="tomcatThreadPool" port="8081" protocol="HTTP/1.1"connectionTimeout="20000"redirectPort="8443" />

<!--基于NIO链接池协议的Connector 性能较好-->
<connector executor="tomcatThreadPool" port="8081" protocol="org.apache.coyote.http11.Http11NioProtocol" connectiontimeout="20000" redirectport="8443">

<p>我们姑且把上面四种Connector按照顺序命名为 NIO, HTTP, POOL, NIOP</p>
<p>为了不让其他因素影响测试结果，我们只对一个很简单的jsp页面进行测试，这个页面仅仅是输出一个Hello World。假设地址是 <a href="http://tomcat1/test.jsp" target="_blank" rel="external">http://tomcat1/test.jsp</a></p>
<p>我们依次对四种Connector进行测试，测试的客户端在另外一台机器上用ab命令来完成，测试命令为： ab -c 900 -n 2000<a href="http://tomcat1/test.jsp，最终的测试结果如下表所示(单位:平均每秒处理的请求数)：" target="_blank" rel="external">http://tomcat1/test.jsp，最终的测试结果如下表所示(单位:平均每秒处理的请求数)：</a></p>
<p>NIO    HTTP    POOL    NIOP<br>281     65     208     365<br>666     66     110     398<br>692     65     66     263<br>256     63     94     459<br>440     67     145     363</p>
<p>由这五组数据不难看出，HTTP的性能是很稳定，但是也是最差的，而这种方式就是Tomcat的默认配置。NIO方式波动很大，但没有低于280 的，NIOP是在NIO的基础上加入线程池，可能是程序处理更复杂了，因此性能不见得比NIO强；而POOL方式则波动很大，测试期间和HTTP方式一样，不时有停滞。</p>
<p>由于linux的内核默认限制了最大打开文件数目是1024，因此此次并发数控制在900。</p>
<p>尽管这一个结果在实际的网站中因为各方面因素导致，可能差别没这么大，例如受限于数据库的性能等等的问题。但对我们在部署网站应用时还是具有参考价值的。</p>
<p>这个可以利用apache server的 ab测试<br>C:\Program Files (x86)\Apache Software Foundation\Apache2.2\bin&gt;ab -n2000 -c100 <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a></p>
<p>或者</p>
<p>C:\Program Files (x86)\Apache Software Foundation\Apache2.2\bin&gt;ab -n2000 -c100 -w <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> &gt;c:/a.html</p>
<p>-n 代表请求数<br>-c 代表并发数<br>-w 输出到</p>
</connector></connector></connector>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tomcat/">tomcat</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-solr-query" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/solr-query/" class="article-date">
  	<time datetime="2016-04-28T09:22:43.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/solr-query/">solr-query</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一. Query参数 </p>
<ol>
<li><p>CoreQueryParam查询的参数<br>1) q: 查询字符串，必须的。<br>2) q.op: 覆盖schema.xml的defaultOperator（有空格时用”AND”还是用”OR”操作逻辑），一般默认指定。<br>3) df: 默认的查询字段，一般默认指定。<br>4) qt: query type，指定查询使用的Query Handler，默认为“standard”。<br>5) wt: writer type。指定查询输出结构格式，默认为“xml”。在solrconfig.xml中定义了查询输出格式：xml、json、python、ruby、php、phps、custom。<br>6) echoHandler：是否在查询结果中显示使用的Query Handler名称。<br>7) echoParams：是否显示查询参数。none：不显示；explicit：只显示查询参数；all：所有，包括在solrconfig.xml定义的Query Handler参数。<br>8) indent - 返回的结果是否缩进，默认关闭，用 indent=true|on 开启，一般调试json,php,phps,ruby输出才有必要用这个参数。<br>9) version - 查询语法的版本，建议不使用它，由服务器指定默认值。 </p>
</li>
<li><p>CommonQueryParameters<br>1) sort：排序，格式：sort=<field name="">+<desc|asc>[,<field name="">+<desc|asc>]„ 。<br>示例：（inStock desc, price asc）表示先 “inStock” 降序, 再 “price” 升序，默认是相关性降序。。<br>2) start：用于分页定义结果起始记录数，默认为0。<br>3) rows：用于分页定义结果每页返回记录数，默认为10。<br>4) fq：filter query。使用Filter Query可以充分利用Filter Query Cache，提高检索性能。作用：在q查询符合结果中同时是fq查询符合的，<br>例如：q=mm&amp;fq=date_time:[20081001 TO 20091031]，找关键字mm，并且date_time是20081001到20091031之间的。<br>5) fl：field list。指定返回结果字段。以空格“ ”或逗号“,”分隔。<br>6) debugQuery：设置返回结果是否显示Debug信息。<br>7) explainOther：设置当debugQuery=true时，显示其他的查询说明。<br>8) defType：设置查询解析器名称。<br>9) timeAllowed：设置查询超时时间。<br>10) omitHeader：设置是否忽略查询结果返回头信息，默认为“false”。 </desc|asc></field></desc|asc></field></p>
</li>
</ol>
<p>二. 查询语法 </p>
<ol>
<li>匹配所有文档：<em>:</em> </li>
<li><p>强制、阻止和可选查询：<br>1) Mandatory：查询结果中必须包括的(for example, only entry name containing the word make) Solr/Lucene Statement：+make, +make +up ,+make +up +kiss<br>2) prohibited：(for example, all documents except those with word believe) Solr/Lucene Statement：+make +up -kiss 3) optional：Solr/Lucene Statement：+make +up kiss </p>
</li>
<li><p>布尔操作：AND、OR和NOT布尔操作（必须大写）与Mandatory、optional和prohibited相似。<br>1) make AND up ＝ +make +up :AND左右两边的操作都是mandatory<br>2) make || up ＝ make OR up＝make up :OR左右两边的操作都是optional<br>3) +make +up NOT kiss ＝ +make +up –kiss<br>4) make AND up OR french AND Kiss不可以达到期望的结果，因为AND两边的操作都是mandatory的。  </p>
</li>
<li><p>子表达式查询（子查询）：可以使用“()”构造子查询。<br>For ex：(make AND up) OR (french AND Kiss) </p>
</li>
<li><p>子表达式查询中阻止查询的限制：<br>For ex:make (-up):只能取得make的查询结果；要使用make (-up <em>:</em>)查询make或者不包括up的结果。  </p>
</li>
<li>多字段fields查询：通过字段名加上分号的方式（fieldName:query）来进行查询<br>For ex：entryNm:make AND entryId:3cdc86e8e0fb4da8ab17caed42f6760c  </li>
<li>通配符查询（wildCard Query）：<br>1) 通配符？和<em>：“</em>”表示匹配任意字符；“？”表示匹配出现的位置。<br>For ex：ma?<em>（ma后面的一个位置匹配），ma??</em>(ma后面两个位置都匹配)<br>2) 查询字符必须要小写：+Ma +be<strong>可以搜索到结果；+Ma +Be</strong>没有搜索结果<br>3) 查询速度较慢，尤其是通配符在首位：主要原因一是需要迭代查询字段中的每个term，判断是否匹配；二是匹配上的term被加到内部的查询，当terms数量达到1024的时候，查询会失败。<br>4) Solr中默认通配符不能出现在首位（可以修改QueryParser，设置 setAllowLeadingWildcard为true）<br>5) set setAllowLeadingWildcard to true. </li>
<li>模糊查询、相似查询：不是精确的查询，通过对查询的字段进行重新插入、删除和转换来取得得分较高的查询解决（由Levenstein Distance Algorithm算法支持）。<br>1) 一般模糊查询：for ex：make-believ~<br>2) 门槛模糊查询：对模糊查询可以设置查询门槛，门槛是0~1之间的数值，门槛<br>越高表面相似度越高。For ex：make-believ~0.5、make-believ~0.8、make-believ~0.9  </li>
<li><p>范围查询（Range Query）：Lucene支持对数字、日期甚至文本的范围查询。结束的范围可以使用“<em>”通配符。<br>For ex：<br>1) 日期范围（ISO-8601 时间GMT）：sa_type:2 AND a_begin_date:[1990-01-01T00:00:00.000Z TO 1999-12-31T24:59:99.999Z]<br>2) 数字：salary:[2000 TO </em>] 3) 文本：entryNm:[a TO a] </p>
</li>
<li><p>日期匹配：YEAR, MONTH, DAY, DATE (synonymous with DAY) HOUR, MINUTE, SECOND, MILLISECOND, and MILLI (synonymous with MILLISECOND)可以被标志成日期。<br>For ex：<br>1) r_event_date:[<em> TO NOW-2YEAR]：2年前的现在这个时间<br>2) r_event_date:[</em> TO NOW/DAY-2YEAR]：2年前前一天的这个时间 </p>
</li>
</ol>
<p>三. 函数查询（Function Query）<br>函数查询 可以利用 numeric域的值 或者 与域相关的的某个特定的值的函数，来对文档进行评分。 </p>
<ol>
<li><p>使用函数查询的方法<br>这里主要有三种方法可以使用函数查询，这三种s方法都是通过solr http接口的。<br>1) 使用FunctionQParserPlugin。ie: q={!func}log(foo)<br>2) 使用“<em>val</em>”内嵌方法内嵌在正常的solr查询表达式中。即，将函数查询写在 q这个参数中，这时候，我们使用“<em>val</em>”将函数与其他的查询加以区别。 ie：entryNm:make &amp;&amp; <em>val</em>:ord(entryNm)<br>3) 使用dismax中的bf参数使用明确为函数查询的参数，比如说dismax中的bf（boost function）这个参数。  注意：bf这个参数是可以接受多个函数查询的，它们之间用空格隔开，它们还可以带上权重。所以，当我们使用bf这个参数的时候，我们必须保证单个函数中是没有空格出现的，不然程序有可能会以为是两个函数。<br>For ex：<br>q=dismax&amp;bf=”ord(popularity)^0.5 recip(rord(price),1,1000,1000)^0.3   2. 函数的格式（Function Query Syntax) 目前，function query 并不支持 a+b 这样的形式，我们得把它写成一个方法形式，这就是 sum(a,b). </p>
</li>
<li><p>使用函数查询注意事项<br>1) 用于函数查询的field必须是被索引的；<br>2) 字段不可以是多值的（multi-value） </p>
</li>
<li><p>可以利用的函数 （available function）<br>1) constant：支持有小数点的常量； 例如：1.5 ；SolrQuerySyntax:<em>val</em>:1.5<br>2) fieldvalue：这个函数将会返回numeric field的值，这个域必须是indexd的，非multiValued的。格式很简单，就是该域的名字。如果这个域中没有这样的值，那么将会返回0。<br>3) ord：对于一个域，它所有的值都将会按照字典顺序排列，这个函数返回你要查询的那个特定的值在这个顺序中的排名。这个域，必须是非multiValued的，当没有值存在的时候，将返回0。例如：某个特定的域只能去三个值，“apple”、“banana”、“pear”，那么ord（“apple”）=1，ord（“banana”）=2，ord（“pear”）=3.需要注意的是，ord（）这个函数，依赖于值在索引中的位置，所以当有文档被删除、或者添加的时候，ord（）的值就会发生变化。当你使用MultiSearcher的时候，这个值也就是不定的了。<br>4) rord：这个函数将会返回与ord相对应的倒排序的排名。 格式: rord(myIndexedField)。<br>5) sum：这个函数的意思就显而易见啦，它就是表示“和”啦。格式：sum(x,1) 、sum(x,y)、 sum(sqrt(x),log(y),z,0.5)<br>6) product：product(x,y,…)将会返回多个函数的乘积。格式：product(x,2)、product(x,y)<br>7) div：div(x,y)表示x除以y的值，格式：div（1,x）、div(sum(x,100),max(y,1))<br>8) pow：pow表示幂值。pow(x,y) =x^y。例如：pow(x,0.5) 表示开方pow(x,log(y))<br>9) abs：abs(x)将返回表达式的绝对值。格式：abs(-5)、 abs(x)<br>10)  log：log(x)将会返回基数为10，x的对数。格式： log(x)、 log(sum(x,100))<br>11)  Sqrt：sqrt(x) 返回 一个数的平方根。格式：sqrt（2）、sqrt(sum(x,100))<br>12)  Map：如果 x&gt;=min,且x&lt;=max,那么map(x,min,max,target)=target.如果 x不在[min,max]这个区间内，那么map(x,min,max,target)=x.  格式：map(x,0,0,1)<br>13) Scale：scale(x,minTarget,maxTarget) 这个函数将会把x的值限制在[minTarget,maxTarget]范围内。 14) query ：query(subquery,default)将会返回给定subquery的分数，如果subquery与文档不匹配，那么将会返回默认值。任何的查询类型都是受支持的。可以通过引用的方式，也可以直接指定查询串。<br>例子：q=product(popularity, query({!dismax v=’solr rocks’}) 将会返回popularity和通过dismax 查询得到的分数的乘积。<br>q=product(popularity, query($qq)&amp;qq={!dismax}solr rocks 跟上一个例子的效果是一样的。不过这里使用的是引用的方式<br>q=product(popularity, query($qq,0.1)&amp;qq={!dismax}solr rocks 在前一个例子的基础上又加了一个默认值。<br>15)  linear： inear(x,m,c)表示 m<em>x+c ,其中m和c都是常量，x是一个变量也可以是一个函数。例如： linear(x,2,4)=2</em>x+4.<br>16) Recip：recip(x,m,a,b)=a/(m*x+b)其中，m、a、b是常量，x是变量或者一个函数。当a=b，并且x&gt;=0的时候，这个函数的最大值是1，值的大小随着x的增大而减小。例如：recip(rord(creationDate),1,1000,1000)<br>17) Max： max(x,c)将会返回一个函数和一个常量之间的最大值。 例如：max(myfield,0)</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/solr/">solr</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mysql跨数据库操作类似与oracle的dblink" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/mysql跨数据库操作类似与oracle的dblink/" class="article-date">
  	<time datetime="2016-04-28T09:21:31.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/mysql跨数据库操作类似与oracle的dblink/">mysql跨数据库操作类似与oracle的dblink</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MySQL FEDERATED 存储引擎</p>
<pre><code>MySQL中针对不同的功能需求提供了不同的存储引擎。所谓的存储引擎也就是MySQL下特定接口的具体实现。
FEDERATED是其中一个专门针对远程数据库的实现。一般情况下在本地数据库中建表会在数据库目录中生成相应的表定义文件，并同时生成相应的数据文件。
</code></pre><p>但通过FEDERATED引擎创建的表只是在本地有表定义文件，数据文件则存在于远程数据库中(这一点很重要)。<br>             通过这个引擎可以实现类似Oracle 下DBLINK的远程数据访问功能。<br>             使用show engines 命令查看数据库是否已支持FEDERATED引擎：</p>
<pre><code>Support 的值有以下几个：
</code></pre><p>YES    支持并开启<br>DEFAULT    支持并开启, 并且为默认引擎<br>NO    不支持<br>DISABLED    支持,但未开启</p>
<p>可以看出MyISAM为当前默认的引擎。<br>                使用FEDERATED建表语句如下：<br>                CREATE TABLE (……) ENGINE =FEDERATED CONNECTION=’mysql://[name]:[pass]@[location]:[port]/[db-name]/[table-name]’<br>               创建成功后就可直接在本地查询相应的远程表了。<br>需要注意的几点：</p>
<pre><code>1. 本地的表结构必须与远程的完全一样。
2.远程数据库目前仅限MySQL
3.不支持事务
4.不支持表结构修改
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle/">oracle</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-github搭建个人博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/hexo-github搭建个人博客/" class="article-date">
  	<time datetime="2016-04-28T09:20:21.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/hexo-github搭建个人博客/">hexo+github搭建个人博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>hexo+github搭建个人博客</p>
<p>字数841 阅读543 评论12 喜欢18<br>现在一个程序猿（媛）没有一个自己的博客都不好意思说自己是程序员，哈哈开玩笑的。是否有一个方法，可以让我们自己创建一个属于自己的博客，然后又不用花钱买服务器和域名，也不用自己找人去设计自己的网站呢。<br>这样的好东西还真的存在，而且配置还十分简单，下面我就详细的介绍如何用hexo+github搭建自己的（酷炫）博客。<br>前期准备</p>
<p>node.js<br>如果你是windows,请戳这里<br>如果你是mac,请戳这里<br>git账号<br>如果没有git帐号，请戳这里<br>安装hexo<br>npm install -g hexo<br>初始化hexo<br>hexo init<br>npm install hexo –save<br>生成静态页面至hexo\public\目录。<br>hexo g<br>本地启动服务<br>hexo server<br>这样，我们就可以在浏览器中输入<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 访问我们的博客啦（响应式的网站）。</p>
<p>初始界面-PC.png</p>
<p>初始界面-移动端.png<br>虽然博客基本的已经搭好了，但是我们只能在本地访问，其他人是看不到的，下面我们通过和git绑定来实现我们想要的效果。</p>
<p>配置github<br>新建一个仓库名（该仓库名和你的用户名对应），如我的git账户名是：coder-Yin，则我的仓库名为coder-Yin.github.io<br>编辑_config.yml文件，建立与git的关联(在.yml文件的最底部)</p>
<h1 id="Deployment-Docs-http-hexo-io-docs-deployment-html"><a href="#Deployment-Docs-http-hexo-io-docs-deployment-html" class="headerlink" title="Deployment## Docs: http://hexo.io/docs/deployment.html"></a>Deployment## Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">http://hexo.io/docs/deployment.html</a></h1><p>deploy:<br>  type: git<br>  repository: <a href="https://github.com/coder-Yin/coder-Yin.github.io.git" target="_blank" rel="external">https://github.com/coder-Yin/coder-Yin.github.io.git</a><br>  branch: master<br>然后运行<br>npm install hexo-deployer-git –save<br>hexo g<br>hexo d<br>这样你就可以在你的 coder-Yin.github.io 上看到代码已经同步到git上了。<br>在浏览器中输入你的**.github..io(例如：<a href="http://coder-yin.github.io/）" target="_blank" rel="external">http://coder-yin.github.io/）</a></p>
<p>访问效果.png<br>每次有新的修改需要部署同步，都可以按照下面的步骤来：<br>hexo clean<br>hexo g<br>hexo d<br>如果你觉得hexo默认的主题不好看，你可以通过以下方法来修改你的主题。</p>
<p>下面我通过修改一个主题来给大家做个介绍：<br>在git上找到你想要的主题<br>我这随意找了一个，比较适合女孩子（缺点:不是自适应的）<br><a href="https://github.com/daisygao/hexo-themes-cover" target="_blank" rel="external">https://github.com/daisygao/hexo-themes-cover</a><br>进入你的hexo目录，执行命令，拷贝主题<br>git clone <a href="https://github.com/daisygao/hexo-themes-cover.git" target="_blank" rel="external">https://github.com/daisygao/hexo-themes-cover.git</a> themes/cover<br>拷贝完成后，你会发现你的项目下的themes下多了一个cover文件夹<br>我们还需要修改_config.yml文件中的一处来应用新的主题</p>
<h1 id="Extensions-Plugins-http-hexo-io-plugins-Themes-http-hexo-io-themes"><a href="#Extensions-Plugins-http-hexo-io-plugins-Themes-http-hexo-io-themes" class="headerlink" title="Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/"></a>Extensions## Plugins: <a href="http://hexo.io/plugins/##" target="_blank" rel="external">http://hexo.io/plugins/##</a> Themes: <a href="http://hexo.io/themes/" target="_blank" rel="external">http://hexo.io/themes/</a></h1><p>theme: cover<br>然后我们重启服务就可以在本地看到效果了<br>hexo server</p>
<p>hexo应用新的主题.png</p>
<p>注意：我们这样只是本地做了修改，git上并没有实现同步，我们需要按照上面所说的，依次执行以下命令实现部署同步：<br>hexo clean<br>hexo g<br>hexo d<br>在刷新你的<a href="http://***.github.io/" target="_blank" rel="external">http://***.github.io/</a> 就可以发现新的主题应用成功了，是不是很简单，快动手建立你自己的博客吧。<br>最后，附上更多的hexo主题，大家可以很戳这里选择你自己喜好的主题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nginx内置变量大全" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/nginx内置变量大全/" class="article-date">
  	<time datetime="2016-04-28T09:19:21.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/nginx内置变量大全/">nginx内置变量大全</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在配置基于nginx服务器的网站时，必然会用到 nginx内置变量 ，下面笔者将它整理成列表，把最新版本的变量列出来，以方便做配置时查询<br>nginx内置变量</p>
<p>内置变量存放在  ngx_http_core_module 模块中，变量的命名方式和apache 服务器变量是一致的。总而言之，这些变量代表着客户端请求头的内容，例如$http_user_agent, $http_cookie, 等等。下面是nginx支持的所有内置变量：<br>$arg_name<br>请求中的的参数名，即“?”后面的arg_name=arg_value形式的arg_name<br>$args<br>请求中的参数值<br>$binary_remote_addr<br>客户端地址的二进制形式, 固定长度为4个字节<br>$body_bytes_sent<br>传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容<br>$bytes_sent<br>传输给客户端的字节数 (1.3.8, 1.2.5)<br>$connection<br>TCP连接的序列号 (1.3.8, 1.2.5)<br>$connection_requests<br>TCP连接当前的请求数量 (1.3.8, 1.2.5)<br>$content_length<br>“Content-Length” 请求头字段<br>$content_type<br>“Content-Type” 请求头字段<br>$cookie_name<br>cookie名称<br>$document_root<br>当前请求的文档根目录或别名<br>$document_uri<br>同 $uri<br>$host<br>优先级如下：HTTP请求行的主机名&gt;”HOST”请求头字段&gt;符合请求的服务器名<br>$hostname<br>主机名<br>$http_name<br>匹配任意请求头字段； 变量名中的后半部分“name”可以替换成任意请求头字段，如在配置文件中需要获取http请求头：“Accept-Language”，那么将“－”替换为下划线，大写字母替换为小写，形如：$http_accept_language即可。<br>$https<br>如果开启了SSL安全模式，值为“on”，否则为空字符串。<br>$is_args<br>如果请求中有参数，值为“?”，否则为空字符串。<br>$limit_rate<br>用于设置响应的速度限制，详见 limit_rate。<br>$msec<br>当前的Unix时间戳 (1.3.9, 1.2.6)<br>$nginx_version<br>nginx版本<br>$pid<br>工作进程的PID<br>$pipe<br>如果请求来自管道通信，值为“p”，否则为“.” (1.3.12, 1.2.7)<br>$proxy_protocol_addr<br>获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串。(1.5.12)<br>$query_string<br>同 $args<br>$realpath_root<br>当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径。<br>$remote_addr<br>客户端地址<br>$remote_port<br>客户端端口<br>$remote_user<br>用于HTTP基础认证服务的用户名<br>$request<br>代表客户端的请求地址<br>$request_body<br>客户端的请求主体<br>此变量可在location中使用，将请求主体通过proxy_pass, fastcgi_pass, uwsgi_pass, 和 scgi_pass传递给下一级的代理服务器。<br>$request_body_file<br>将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off, uwsgi_pass_request_body off, or scgi_pass_request_body off 。<br>$request_completion<br>如果请求成功，值为”OK”，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空。<br>$request_filename<br>当前连接请求的文件路径，由root或alias指令与URI请求生成。<br>$request_length<br>请求的长度 (包括请求的地址, http请求头和请求主体) (1.3.12, 1.2.7)<br>$request_method<br>HTTP请求方法，通常为“GET”或“POST”<br>$request_time<br>处理客户端请求使用的时间 (1.3.9, 1.2.6); 从读取客户端的第一个字节开始计时。<br>$request_uri<br>这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：”/cnphp/test.php?arg=freemouse”。<br>$scheme<br>请求使用的Web协议, “http” 或 “https”<br>$sent_http_name<br>可以设置任意http响应头字段； 变量名中的后半部分“name”可以替换成任意响应头字段，如需要设置响应头Content-length，那么将“－”替换为下划线，大写字母替换为小写，形如：$sent_http_content_length 4096即可。<br>$server_addr<br>服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中。<br>$server_name<br>服务器名，www.cnphp.info<br>$server_port<br>服务器端口<br>$server_protocol<br>服务器的HTTP版本, 通常为 “HTTP/1.0” 或 “HTTP/1.1”<br>$status<br>HTTP响应代码 (1.3.2, 1.2.2)<br>$tcpinfo_rtt, $tcpinfo_rttvar, $tcpinfo_snd_cwnd, $tcpinfo_rcv_space<br>客户端TCP连接的具体信息<br>$time_iso8601<br>服务器时间的ISO 8610格式 (1.3.12, 1.2.7)<br>$time_local<br>服务器时间（LOG Format 格式） (1.3.12, 1.2.7)<br>$uri<br>请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如”/foo/bar.html”。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mysql主从同步" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/mysql主从同步/" class="article-date">
  	<time datetime="2016-04-28T09:18:13.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/mysql主从同步/">mysql主从同步</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前提条件两个数据库并且局域网能够访问并且两个数据库的版本号要一致（msyql -V 查看mysql版本号）。<br>否则容易出现莫名错误不好处理。<br>1:主数据库141（10.10.39.101）下面称作master<br>2:从数据库142（10.10.49.90）下面称作slave</p>
<p>配置如下<br>1:在主服务器上,设置一个从数据库的账户,使用REPLICATION SLAVE赋予权限,如:<br>mysql&gt; GRANT REPLICATION SLAVE ON <em>.</em> TO ‘slave001’@’10.10.49.90’ IDENTIFIED BY ‘1qazZZR@WSX’;</p>
<p>2:修改主数据库的配置文件my.cnf,开启BINLOG，并设置server-id的值，修改之后必须重启Mysql服务<br>[mysqld]<br>log-bin = mysql-bin<br>server-id=141</p>
<p>3:之后可以得到主服务器当前二进制日志名和偏移量，这个操作的目的是为了在从数据库启动后，从这个<br>点开始进行数据的恢复<br>mysql&gt; show master status\G;<br><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong><br>File: mysql-bin.000003<br>Position: 243<br>Binlog_Do_DB:<br>Binlog_Ignore_DB:<br>1 row in set (0.00 sec)<br>4:停止对master数据库的更新然后导出需要同步的数据库，<br>mysql&gt; flush tables with read lock;<br>mysqldump -h127.0.0.1 -p3306 -uroot -p zzr &gt; /home/zzr.sql<br>mysql&gt; unlock tables;<br>5：将刚才主数据备份的zzr.sql复制到从数据库，进行导入<br>6：接着修改从数据库的my.cnf,增加server-id参数,指定复制使用的用户,主数据库服务器的ip,端口以及开始执<br>行复制日志的文件和位置<br>[mysqld]<br>server-id=142<br>log_bin = mysql-bin<br>master-host =10.10.39.101<br>master-user=slave001<br>master-pass=1qazZZR@WSX<br>master-port =20010<br>master-connect-retry=60<br>replicate-do-db =zzr,open<br>7:在从服务器上,启动slave进程<br>mysql&gt; start slave;<br>    如果启动失败：在slave上强制执行<br>    mysql&gt; change master to master_host=’master_host’, master_user=’you_user_name’, master_password=’you_master_user_password’,master_log_file=’mysqld-bin.000001’,master_port=3306, master_log_pos=98;<br>   （master_log_file和master_log_pos）的值你可以在服务器上运行 show master status; 来得到。<br>    然后 mysql&gt; start slave;启动slave进程<br>8:在从服务器进行show salve status验证<br>mysql&gt; SHOW SLAVE STATUS\G<br>9：检测一下。看看是否主从同步了。 </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java操作MongoDB" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/Java操作MongoDB/" class="article-date">
  	<time datetime="2016-04-28T09:17:23.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/Java操作MongoDB/">Java操作MongoDB</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MongoDB for Java】Java操作MongoDB</p>
<p>上一篇文章: <a href="http://www.cnblogs.com/hoojo/archive/2011/06/01/2066426.html介绍到了在MongoDB的控制台完成MongoDB的数据操作，通过前一篇文章我们对MongoDB有了全面的认识和理解。现在我们就用Java来操作MongoDB的数据。" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2011/06/01/2066426.html介绍到了在MongoDB的控制台完成MongoDB的数据操作，通过前一篇文章我们对MongoDB有了全面的认识和理解。现在我们就用Java来操作MongoDB的数据。</a></p>
<p>开发环境：<br>System：Windows<br>IDE：eclipse、MyEclipse 8<br>Database：mongoDB<br>开发依赖库：<br>JavaEE5、mongo-2.5.3.jar、junit-4.8.2.jar<br>Email：hoojo_@126.com<br>Blog：<a href="http://blog.csdn.net/IBM_hoojo" target="_blank" rel="external">http://blog.csdn.net/IBM_hoojo</a><br><a href="http://hoojo.cnblogs.com/" target="_blank" rel="external">http://hoojo.cnblogs.com/</a></p>
<p>一、准备工作</p>
<p>1、 首先，下载mongoDB对Java支持的驱动包<br>驱动包下载地址：<a href="https://github.com/mongodb/mongo-java-driver/downloads" target="_blank" rel="external">https://github.com/mongodb/mongo-java-driver/downloads</a><br>mongoDB对Java的相关支持、技术：<a href="http://www.mongodb.org/display/DOCS/Java+Language+Center" target="_blank" rel="external">http://www.mongodb.org/display/DOCS/Java+Language+Center</a><br>驱动源码下载：<a href="https://download.github.com/mongodb-mongo-java-driver-r2.6.1-7-g6037357.zip" target="_blank" rel="external">https://download.github.com/mongodb-mongo-java-driver-r2.6.1-7-g6037357.zip</a><br>在线查看源码：<a href="https://github.com/mongodb/mongo-java-driver" target="_blank" rel="external">https://github.com/mongodb/mongo-java-driver</a><br>2、 下面建立一个JavaProject工程，导入下载下来的驱动包。即可在Java中使用mongoDB，目录如下：</p>
<p>二、Java操作MongoDB示例</p>
<p>在本示例之前你需要启动mongod.exe的服务，启动后，下面的程序才能顺利执行；</p>
<p>1、 建立SimpleTest.java，完成简单的mongoDB数据库操作<br>Mongo mongo = new Mongo();<br>这样就创建了一个MongoDB的数据库连接对象，它默认连接到当前机器的localhost地址，端口是27017。<br>DB db = mongo.getDB(“test”);<br>这样就获得了一个test的数据库，如果mongoDB中没有创建这个数据库也是可以正常运行的。如果你读过上一篇文章就知道，mongoDB可以在没有创建这个数据库的情况下，完成数据的添加操作。当添加的时候，没有这个库，mongoDB会自动创建当前数据库。<br>得到了db，下一步我们要获取一个“聚集集合DBCollection”，通过db对象的getCollection方法来完成。<br>DBCollection users = db.getCollection(“users”);<br>这样就获得了一个DBCollection，它相当于我们数据库的“表”。<br>查询所有数据<br>DBCursor cur = users.find();<br>while (cur.hasNext()) {<br>System.out.println(cur.next());<br>}</p>
<p>完整源码<br>package com.hoo.test;</p>
<p>import java.net.UnknownHostException;<br>import com.mongodb.DB;<br>import com.mongodb.DBCollection;<br>import com.mongodb.DBCursor;<br>import com.mongodb.Mongo;<br>import com.mongodb.MongoException;<br>import com.mongodb.util.JSON;</p>
<p>/**</p>
<ul>
<li><b>function:</b>MongoDB 简单示例</li>
<li>@author hoojo</li>
<li>@createDate 2011-5-24 下午02:42:29</li>
<li>@file SimpleTest.java</li>
<li>@package com.hoo.test</li>
<li>@project MongoDB</li>
<li>@blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank" rel="external">http://blog.csdn.net/IBM_hoojo</a></li>
<li>@email hoojo_@126.com</li>
<li>@version 1.0<br>*/<br>publicclass SimpleTest {</li>
</ul>
<p>publicstaticvoid main(String[] args) throws UnknownHostException, MongoException {<br>        Mongo mg = new Mongo();<br>//查询所有的Database<br>for (String name : mg.getDatabaseNames()) {<br>            System.out.println(“dbName: “ + name);<br>        }<br>        DB db = mg.getDB(“test”);<br>//查询所有的聚集集合<br>for (String name : db.getCollectionNames()) {<br>            System.out.println(“collectionName: “ + name);<br>        }<br>        DBCollection users = db.getCollection(“users”);<br>//查询所有的数据<br>        DBCursor cur = users.find();<br>while (cur.hasNext()) {<br>            System.out.println(cur.next());<br>        }<br>        System.out.println(cur.count());<br>        System.out.println(cur.getCursorId());<br>        System.out.println(JSON.serialize(cur));<br>    }<br>}</p>
<p>2、 完成CRUD操作，首先建立一个MongoDB4CRUDTest.java，基本测试代码如下：<br>package com.hoo.test;</p>
<p>import java.net.UnknownHostException;<br>import java.util.ArrayList;<br>import java.util.List;<br>import org.bson.types.ObjectId;<br>import org.junit.After;<br>import org.junit.Before;<br>import org.junit.Test;<br>import com.mongodb.BasicDBObject;<br>import com.mongodb.Bytes;<br>import com.mongodb.DB;<br>import com.mongodb.DBCollection;<br>import com.mongodb.DBCursor;<br>import com.mongodb.DBObject;<br>import com.mongodb.Mongo;<br>import com.mongodb.MongoException;<br>import com.mongodb.QueryOperators;<br>import com.mongodb.util.JSON;</p>
<p>/**</p>
<ul>
<li><b>function:</b>实现MongoDB的CRUD操作</li>
<li>@author hoojo</li>
<li>@createDate 2011-6-2 下午03:21:23</li>
<li>@file MongoDB4CRUDTest.java</li>
<li>@package com.hoo.test</li>
<li>@project MongoDB</li>
<li>@blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank" rel="external">http://blog.csdn.net/IBM_hoojo</a></li>
<li>@email hoojo_@126.com</li>
<li>@version 1.0<br>*/<br>publicclass MongoDB4CRUDTest {<br>private Mongo mg = null;<br>private DB db;<br>private DBCollection users;<br> @Before<br>publicvoid init() {<br>try {<pre><code>mg = new Mongo();
</code></pre>//mg = new Mongo(“localhost”, 27017);<pre><code>} catch (UnknownHostException e) {
    e.printStackTrace();
} catch (MongoException e) {
    e.printStackTrace();
}
</code></pre>//获取temp DB；如果默认没有创建，mongodb会自动创建<pre><code>db = mg.getDB(&quot;temp&quot;);
</code></pre>//获取users DBCollection；如果默认没有创建，mongodb会自动创建<pre><code>users = db.getCollection(&quot;users&quot;);
</code></pre> }<br> @After<br>publicvoid destory() {<br>if (mg != null)<pre><code>    mg.close();
mg = null;
db = null;
users = null;
System.gc();
</code></pre> }<br>publicvoid print(Object o) {<pre><code>System.out.println(o);
</code></pre> }<br>}</li>
</ul>
<p>3、 添加操作<br>在添加操作之前，我们需要写个查询方法，来查询所有的数据。代码如下：<br>/**</p>
<ul>
<li><b>function:</b> 查询所有数据</li>
<li>@author hoojo</li>
<li>@createDate 2011-6-2 下午03:22:40<br>*/<br>privatevoid queryAll() {<br> print(“查询users的所有数据：”);<br>//db游标<br> DBCursor cur = users.find();<br>while (cur.hasNext()) {<pre><code>print(cur.next());
</code></pre> }<br>}</li>
</ul>
<p>@Test<br>publicvoid add() {<br>//先查询所有数据<br>    queryAll();<br>    print(“count: “ + users.count());<br>    DBObject user = new BasicDBObject();<br>    user.put(“name”, “hoojo”);<br>    user.put(“age”, 24);<br>//users.save(user)保存，getN()获取影响行数<br>//print(users.save(user).getN());<br>//扩展字段，随意添加字段，不影响现有数据<br>    user.put(“sex”, “男”);<br>    print(users.save(user).getN());<br>//添加多条数据，传递Array对象<br>    print(users.insert(user, new BasicDBObject(“name”, “tom”)).getN());<br>//添加List集合<br>    List<dbobject> list = new ArrayList<dbobject>();<br>    list.add(user);<br>    DBObject user2 = new BasicDBObject(“name”, “lucy”);<br>    user.put(“age”, 22);<br>    list.add(user2);<br>//添加List集合<br>    print(users.insert(list).getN());<br>//查询下数据，看看是否添加成功<br>    print(“count: “ + users.count());<br>    queryAll();<br>}</dbobject></dbobject></p>
<p>4、 删除数据<br>@Test<br>publicvoid remove() {<br>    queryAll();<br>    print(“删除id = 4de73f7acd812d61b4626a77：” + users.remove(new BasicDBObject(“_id”, new ObjectId(“4de73f7acd812d61b4626a77”))).getN());<br>    print(“remove age &gt;= 24: “ + users.remove(new BasicDBObject(“age”, new BasicDBObject(“$gte”, 24))).getN());<br>}</p>
<p>5、 修改数据<br>@Test<br>publicvoid modify() {<br>    print(“修改：” + users.update(new BasicDBObject(“_id”, new ObjectId(“4dde25d06be7c53ffbd70906”)), new BasicDBObject(“age”, 99)).getN());<br>    print(“修改：” + users.update(<br>new BasicDBObject(“_id”, new ObjectId(“4dde2b06feb038463ff09042”)),<br>new BasicDBObject(“age”, 121),<br>            true,//如果数据库不存在，是否添加<br>            false//多条修改<br>            ).getN());<br>    print(“修改：” + users.update(<br>new BasicDBObject(“name”, “haha”),<br>new BasicDBObject(“name”, “dingding”),<br>            true,//如果数据库不存在，是否添加<br>            true//false只修改第一天，true如果有多条就不修改<br>            ).getN());<br>//当数据库不存在就不修改、不添加数据，当多条数据就不修改<br>//print(“修改多条：” + coll.updateMulti(new BasicDBObject(“_id”, new ObjectId(“4dde23616be7c19df07db42c”)), new BasicDBObject(“name”, “199”)));<br>}</p>
<p>6、 查询数据<br>@Test<br>publicvoid query() {<br>//查询所有<br>//queryAll();<br>//查询id = 4de73f7acd812d61b4626a77<br>    print(“find id = 4de73f7acd812d61b4626a77: “ + users.find(new BasicDBObject(“_id”, new ObjectId(“4de73f7acd812d61b4626a77”))).toArray());<br>//查询age = 24<br>    print(“find age = 24: “ + users.find(new BasicDBObject(“age”, 24)).toArray());<br>//查询age &gt;= 24<br>    print(“find age &gt;= 24: “ + users.find(new BasicDBObject(“age”, new BasicDBObject(“$gte”, 24))).toArray());<br>    print(“find age &lt;= 24: “ + users.find(new BasicDBObject(“age”, new BasicDBObject(“$lte”, 24))).toArray());<br>    print(“查询age!=25：” + users.find(new BasicDBObject(“age”, new BasicDBObject(“$ne”, 25))).toArray());<br>    print(“查询age in 25/26/27：” + users.find(new BasicDBObject(“age”, new BasicDBObject(QueryOperators.IN, newint[] { 25, 26, 27 }))).toArray());<br>    print(“查询age not in 25/26/27：” + users.find(new BasicDBObject(“age”, new BasicDBObject(QueryOperators.NIN, newint[] { 25, 26, 27 }))).toArray());<br>    print(“查询age exists 排序：” + users.find(new BasicDBObject(“age”, new BasicDBObject(QueryOperators.EXISTS, true))).toArray());<br>    print(“只查询age属性：” + users.find(null, new BasicDBObject(“age”, true)).toArray());<br>    print(“只查属性：” + users.find(null, new BasicDBObject(“age”, true), 0, 2).toArray());<br>    print(“只查属性：” + users.find(null, new BasicDBObject(“age”, true), 0, 2, Bytes.QUERYOPTION_NOTIMEOUT).toArray());<br>//只查询一条数据，多条去第一条<br>    print(“findOne: “ + users.findOne());<br>    print(“findOne: “ + users.findOne(new BasicDBObject(“age”, 26)));<br>    print(“findOne: “ + users.findOne(new BasicDBObject(“age”, 26), new BasicDBObject(“name”, true)));<br>//查询修改、删除<br>    print(“findAndRemove 查询age=25的数据，并且删除: “ + users.findAndRemove(new BasicDBObject(“age”, 25)));<br>//查询age=26的数据，并且修改name的值为Abc<br>    print(“findAndModify: “ + users.findAndModify(new BasicDBObject(“age”, 26), new BasicDBObject(“name”, “Abc”)));<br>    print(“findAndModify: “ + users.findAndModify(<br>new BasicDBObject(“age”, 28), //查询age=28的数据<br>new BasicDBObject(“name”, true), //查询name属性<br>new BasicDBObject(“age”, true), //按照age排序<br>        false, //是否删除，true表示删除<br>new BasicDBObject(“name”, “Abc”), //修改的值，将name修改成Abc<br>        true,<br>        true));<br>    queryAll();<br>}<br>mongoDB不支持联合查询、子查询，这需要我们自己在程序中完成。将查询的结果集在Java查询中进行需要的过滤即可。</p>
<p>7、 其他操作<br>publicvoid testOthers() {<br>    DBObject user = new BasicDBObject();<br>    user.put(“name”, “hoojo”);<br>    user.put(“age”, 24);<br>//JSON 对象转换<br>    print(“serialize: “ + JSON.serialize(user));<br>//反序列化<br>    print(“parse: “ + JSON.parse(“{ \”name\” : \”hoojo\” , \”age\” : 24}”));<br>    print(“判断temp Collection是否存在: “ + db.collectionExists(“temp”));<br>//如果不存在就创建<br>if (!db.collectionExists(“temp”)) {<br>        DBObject options = new BasicDBObject();<br>        options.put(“size”, 20);<br>        options.put(“capped”, 20);<br>        options.put(“max”, 20);<br>        print(db.createCollection(“account”, options));<br>    }<br>//设置db为只读<br>    db.setReadOnly(true);<br>//只读不能写入数据<br>    db.getCollection(“test”).save(user);<br>}</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongodb/">mongodb</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-memcache安装及配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/memcache安装及配置/" class="article-date">
  	<time datetime="2016-04-28T09:16:27.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/memcache安装及配置/">memcache安装及配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CentOS6.4安装Memcached与使用例子</p>
<p>1、安装libevent<br>    wget <a href="http://monkey.org/~provos/libevent-1.4.14b-stable.tar.gz" target="_blank" rel="external">http://monkey.org/~provos/libevent-1.4.14b-stable.tar.gz</a><br>    tar zxvf libevent-1.4.14b-stable.tar.gz<br>    cd libevent-1.4.14b-stable<br>    ./configure –prefix=/usr/local/libevent/<br>    make &amp;&amp; make install<br>    ln -s /usr/local/libevent/lib/libevent-1.4.so.2 /lib/libevent-1.4.so.2<br>   /**<br>      1) 如果共享库文件安装到了/lib或/usr/lib目录下, 那么需执行一下ldconfig命令</p>
<p>ldconfig命令的用途, 主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下, 搜索出可共享的动态链接库(格式如lib<em>.so</em>), 进而创建出动态装入程序(ld.so)所需的连接和缓存文件. 缓存文件默认为/etc/ld.so.cache, 此文件保存已排好序的动态链接库名字列表. </p>
<p>2) 如果共享库文件安装到了/usr/local/lib(很多开源的共享库都会安装到该目录下)或其它”非/lib或/usr/lib”目录下, 那么在执行ldconfig命令前, 还要把新共享库目录加入到共享库配置文件/etc/ld.so.conf中, 如下:</p>
<h1 id="cat-etc-ld-so-conf"><a href="#cat-etc-ld-so-conf" class="headerlink" title="cat /etc/ld.so.conf"></a>cat /etc/ld.so.conf</h1><p>include ld.so.conf.d/*.conf</p>
<h1 id="echo-“-usr-local-lib”-gt-gt-etc-ld-so-conf"><a href="#echo-“-usr-local-lib”-gt-gt-etc-ld-so-conf" class="headerlink" title="echo “/usr/local/lib” &gt;&gt; /etc/ld.so.conf"></a>echo “/usr/local/lib” &gt;&gt; /etc/ld.so.conf</h1><h1 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h1><p>3) 如果共享库文件安装到了其它”非/lib或/usr/lib” 目录下,  但是又不想在/etc/ld.so.conf中加路径(或者是没有权限加路径). 那可以export一个全局变量LD_LIBRARY_PATH, 然后运行程序的时候就会去这个目录中找共享库. </p>
<p>LD_LIBRARY_PATH的意思是告诉loader在哪些目录中可以找到共享库. 可以设置多个搜索目录, 这些目录之间用冒号分隔开. 比如安装了一个mysql到/usr/local/mysql目录下, 其中有一大堆库文件在/usr/local/mysql/lib下面, 则可以在.bashrc或.bash_profile或shell里加入以下语句即可:</p>
<p>export LD_LIBRARY_PATH=/usr/local/mysql/lib:$LD_LIBRARY_PATH    </p>
<p>一般来讲这只是一种临时的解决方案, 在没有权限或临时需要的时候使用.</p>
<p>4）如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<br>比如：<br>error while loading shared libraries: libncurses.so.4: cannot open shared<br>object file: No such file or directory</p>
<p>ls /usr/lib/libncu*<br>/usr/lib/libncurses.a   /usr/lib/libncurses.so.5<br>/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3</p>
<p>可见虽然没有libncurses.so.4，但有libncurses.so.5，是可以向下兼容的<br>建一个链接就好了<br>ln -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4</p>
<p>**/</p>
<p>2、安装Memcached<br>    wget <a href="http://www.danga.com/memcached/dist/memcached-1.2.0.tar.gz" target="_blank" rel="external">http://www.danga.com/memcached/dist/memcached-1.2.0.tar.gz</a><br>    tar zxvf memcached-1.4.15.tar.gz<br>    cd memcached-1.4.15<br>    ./configure –prefix=/usr/local/memcached/ –with-libevent=/usr/local/libevent/<br>    make &amp;&amp; make install<br>3、启动Memcached<br>     /usr/local/memcached/bin/memcached -d -m 64 -u root -l 127.0.0.100 -p 11211 -c 128 -P /tmp/memcached.pid<br>4、为了方便管理，写个SHELL脚本吧。</p>
<p> vi /etc/rc.d/init.d/memcached</p>
<pre><code>#!/bin/sh
#
# memcached: MemCached Daemon
#
# chkconfig: - 90 25
# description: MemCached Daemon
#
# Source function library.
. /etc/rc.d/init.d/functions
. /etc/sysconfig/network
#[ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0
#[ -r /etc/sysconfig/dund ] || exit 0
#. /etc/sysconfig/dund
#[ -z &quot;$DUNDARGS&quot; ] &amp;&amp; exit 0
start()
{
echo -n $&quot;Starting memcached: &quot;
daemon $MEMCACHED -u daemon -d -m 64 -l 127.0.0.100 -p 11211 -c 128 -P /tmp/memcached.pid
echo
}
stop()
{
echo -n $&quot;Shutting down memcached: &quot;
killproc memcached
echo
}
MEMCACHED=&quot;/usr/local/memcached/bin/memcached&quot;
[ -f $MEMCACHED ] || exit 1
# See how we were called.
case &quot;$1&quot; in
start)
start
;;
stop)
stop
;;
restart)
stop
sleep 3
start
;;
*)
echo $&quot;Usage: $0 {start|stop|restart}&quot;
exit 1
esac
exit 0
</code></pre><p>5、添加Memcached开机启动<br>    cd /etc/rc.d/init.d/<br>    chmod 777 memcached<br>    chkconfig –add memcached<br>    chkconfig –level 235 memcached on<br>    chkconfig –list | grep memcached<br>6、Memcached使用<br>    [root@www.111cn.net] service memcached start<br>    [root@www.111cn.net] service memcached stop<br>    [root@www.111cn.net] service memcached restart</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcached/">memcached</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 菜菜
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>