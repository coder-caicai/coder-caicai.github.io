<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>菜菜的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="菜菜的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="菜菜的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="菜菜的博客">
<meta property="og:description" content="菜菜的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="菜菜的博客">
<meta name="twitter:description" content="菜菜的博客">
  
    <link rel="alternative" href="/atom.xml" title="菜菜的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">菜菜</a></h1>
		</hgroup>

		
		<p class="header-subtitle">菜菜的博客</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags">标签</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/git/" style="font-size: 13.33px;">git</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/memcached/" style="font-size: 10px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/soa/" style="font-size: 16.67px;">soa</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.didispace.com">程序猿DD</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">菜菜</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/ccz.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">菜菜</h1>
			</hgroup>
			
			<p class="header-subtitle">菜菜的博客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">标签</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-SpringBoot中使用-Scheduled创建定时任务" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用-Scheduled创建定时任务/" class="article-date">
  	<time datetime="2016-06-15T09:27:19.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用-Scheduled创建定时任务/">SpringBoot中使用@Scheduled创建定时任务</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用@Scheduled创建定时任务<br>2016年05月15日 标签：Spring Boot<br>我们在编写Spring Boot应用中经常会遇到这样的场景，比如：我需要定时地发送一些短信、邮件之类的操作，也可能会定时地检查和监控一些标志、参数等。</p>
<p>创建定时任务<br>在Spring Boot中编写定时任务是非常简单的事，下面通过实例介绍如何在Spring Boot中创建定时任务，实现每过5秒输出一下当前时间。</p>
<p>在Spring Boot的主类中加入@EnableScheduling注解，启用定时任务的配置<br>@SpringBootApplication<br>@EnableScheduling<br>public class Application {</p>
<pre><code>public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}
</code></pre><p>}<br>创建定时任务实现类<br>@Component<br>public class ScheduledTasks {</p>
<pre><code>private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);

@Scheduled(fixedRate = 5000)
public void reportCurrentTime() {
    System.out.println(&quot;现在时间：&quot; + dateFormat.format(new Date()));
}
</code></pre><p>}<br>运行程序，控制台中可以看到类似如下输出，定时任务开始正常运作了。<br>2016-05-15 10:40:04.073  INFO 1688 — [           main] com.didispace.Application                : Started Application in 1.433 seconds (JVM running for 1.967)<br>现在时间：10:40:09<br>现在时间：10:40:14<br>现在时间：10:40:19<br>现在时间：10:40:24<br>现在时间：10:40:29522<br>现在时间：10:40:34<br>关于上述的简单入门示例也可以参见官方的Scheduling Tasks</p>
<p>@Scheduled详解<br>在上面的入门例子中，使用了@Scheduled(fixedRate = 5000) 注解来定义每过5秒执行的任务，对于@Scheduled的使用可以总结如下几种方式：</p>
<p>@Scheduled(fixedRate = 5000) ：上一次开始执行时间点之后5秒再执行<br>@Scheduled(fixedDelay = 5000) ：上一次执行完毕时间点之后5秒再执行<br>@Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次<br>@Scheduled(cron=”<em>/5 </em> <em> </em> <em> </em>“) ：通过cron表达式定义规则<br>完整示例Chapter4-1-1</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot属性配置文件详解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot属性配置文件详解/" class="article-date">
  	<time datetime="2016-06-15T09:26:27.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot属性配置文件详解/">SpringBoot属性配置文件详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot属性配置文件详解<br>2016年05月05日 标签：Spring Boot<br>相信很多人选择Spring Boot主要是考虑到它既能兼顾Spring的强大功能，还能实现快速开发的便捷。我们在Spring Boot使用过程中，最直观的感受就是没有了原来自己整合Spring应用时繁多的XML配置内容，替代它的是在pom.xml中引入模块化的Starter POMs，其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在application.properties中完成一些属性配置就能开启各模块的应用。</p>
<p>在之前的各篇文章中都有提及关于application.properties的使用，主要用来配置数据库连接、日志相关配置等。除了这些配置内容之外，本文将具体介绍一些在application.properties配置中的其他特性和使用方法。</p>
<p>自定义属性与加载<br>我们在使用Spring Boot的时候，通常也需要定义一些自己使用的属性，我们可以如下方式直接定义：</p>
<p>com.didispace.blog.name=程序猿DD<br>com.didispace.blog.title=Spring Boot教程<br>然后通过@Value(“${属性名}”)注解来加载对应的配置属性，具体如下：</p>
<p>@Component<br>public class BlogProperties {</p>
<pre><code>@Value(&quot;${com.didispace.blog.name}&quot;)
private String name;
@Value(&quot;${com.didispace.blog.title}&quot;)
private String title;

// 省略getter和setter
</code></pre><p>}<br>按照惯例，通过单元测试来验证BlogProperties中的属性是否已经根据配置文件加载了。</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private BlogProperties blogProperties;


@Test
public void getHello() throws Exception {
    Assert.assertEquals(blogProperties.getName(), &quot;程序猿DD&quot;);
    Assert.assertEquals(blogProperties.getTitle(), &quot;Spring Boot教程&quot;);
}
</code></pre><p>}<br>参数间的引用<br>在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置：</p>
<p>com.didispace.blog.name=程序猿DD<br>com.didispace.blog.title=Spring Boot教程<br>com.didispace.blog.desc=${com.didispace.blog.name}正在努力写《${com.didispace.blog.title}》<br>com.didispace.blog.desc参数引用了上文中定义的name和title属性，最后该属性的值就是程序猿DD正在努力写《Spring Boot教程》。</p>
<p>使用随机数<br>在一些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。</p>
<h1 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h1><p>com.didispace.blog.value=${random.value}  </p>
<h1 id="随机int"><a href="#随机int" class="headerlink" title="随机int"></a>随机int</h1><p>com.didispace.blog.number=${random.int}  </p>
<h1 id="随机long"><a href="#随机long" class="headerlink" title="随机long"></a>随机long</h1><p>com.didispace.blog.bignumber=${random.long}  </p>
<h1 id="10以内的随机数"><a href="#10以内的随机数" class="headerlink" title="10以内的随机数"></a>10以内的随机数</h1><p>com.didispace.blog.test1=${random.int(10)}  </p>
<h1 id="10-20的随机数"><a href="#10-20的随机数" class="headerlink" title="10-20的随机数"></a>10-20的随机数</h1><p>com.didispace.blog.test2=${random.int[10,20]}<br>通过命令行设置属性值<br>相信使用过一段时间Spring Boot的用户，一定知道这条命令：java -jar xxx.jar –server.port=8888，通过使用–server.port属性来设置xxx.jar应用的端口为8888。</p>
<p>在命令行运行时，连续的两个减号–就是对application.properties中的属性值进行赋值的标识。所以，java -jar xxx.jar –server.port=8888命令，等价于我们在application.properties中添加属性server.port=8888，该设置在样例工程中可见，读者可通过删除该值或使用命令行来设置该值来验证。</p>
<p>通过命令行来修改属性值固然提供了不错的便利性，但是通过命令行就能更改应用运行的参数，那岂不是很不安全？是的，所以Spring Boot也贴心的提供了屏蔽命令行访问属性的设置，只需要这句设置就能屏蔽：SpringApplication.setAddCommandLineProperties(false)。</p>
<p>多环境配置<br>我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。</p>
<p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p>
<p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如：</p>
<p>application-dev.properties：开发环境<br>application-test.properties：测试环境<br>application-prod.properties：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。</p>
<p>如：spring.profiles.active=test就会加载application-test.properties配置文件内容</p>
<p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p>
<p>针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties</p>
<p>在这三个文件均都设置不同的server.port属性，如：dev环境设置为1111，test环境设置为2222，prod环境设置为3333</p>
<p>application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置</p>
<p>测试不同配置的加载</p>
<p>执行java -jar xxx.jar，可以观察到服务端口被设置为1111，也就是默认的开发环境（dev）<br>执行java -jar xxx.jar –spring.profiles.active=test，可以观察到服务端口被设置为2222，也就是测试环境的配置（test）<br>执行java -jar xxx.jar –spring.profiles.active=prod，可以观察到服务端口被设置为3333，也就是生产环境的配置（prod）<br>按照上面的实验，可以如下总结多环境的配置思路：</p>
<p>application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置<br>application-{profile}.properties中配置各个环境不同的内容<br>通过命令行方式去激活不同环境的配置</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中Web应用的统一异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中Web应用的统一异常处理/" class="article-date">
  	<time datetime="2016-06-15T09:25:16.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中Web应用的统一异常处理/">SpringBoot中Web应用的统一异常处理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中Web应用的统一异常处理<br>2016年05月02日 标签：Spring Boot<br>我们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。</p>
<p>选择一个之前实现过的Web应用（Chapter3-1-2）为基础，启动该应用，访问一个不存在的URL，或是修改处理内容，直接抛出异常，如：</p>
<p>@RequestMapping(“/hello”)<br>public String hello() throws Exception {<br>    throw new Exception(“发生错误”);<br>}<br>此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。</p>
<p>alt=默认的错误页面</p>
<p>统一异常处理<br>虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面你的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。</p>
<p>下面我们以之前的Web应用例子为基础（Chapter3-1-2），进行统一异常处理的改造。</p>
<p>创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中<br>@ControllerAdvice<br>class GlobalExceptionHandler {</p>
<pre><code>public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;;

@ExceptionHandler(value = Exception.class)
public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
    ModelAndView mav = new ModelAndView();
    mav.addObject(&quot;exception&quot;, e);
    mav.addObject(&quot;url&quot;, req.getRequestURL());
    mav.setViewName(DEFAULT_ERROR_VIEW);
    return mav;
}
</code></pre><p>}<br>实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;  </span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;统一异常处理&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;  </span><br><span class="line">&lt;body&gt;  </span><br><span class="line">    &lt;h1&gt;Error Handler&lt;/h1&gt;</span><br><span class="line">    &lt;div th:text=&quot;$&#123;url&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div th:text=&quot;$&#123;exception.message&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>启动该应用，访问：<a href="http://localhost:8080/hello，可以看到如下错误提示页面。" target="_blank" rel="external">http://localhost:8080/hello，可以看到如下错误提示页面。</a></p>
<p>alt=自定义的错误页面</p>
<p>通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。</p>
<p>返回JSON格式<br>在上述例子中，通过@ControllerAdvice统一定义不同Exception映射到不同错误处理页面。而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。</p>
<p>本质上，只需在@ExceptionHandler之后加入@ResponseBody，就能让处理函数return的内容转换为JSON格式。</p>
<p>下面以一个具体示例来实现返回JSON格式的异常处理。</p>
<p>创建统一的JSON返回对象，code：消息类型，message：消息内容，url：请求的url，data：请求返回的数据<br>public class ErrorInfo<t> {</t></p>
<pre><code>public static final Integer OK = 0;
public static final Integer ERROR = 100;

private Integer code;
private String message;
private String url;
private T data;

// 省略getter和setter
</code></pre><p>}<br>创建一个自定义异常，用来实验捕获该异常，并返回json<br>public class MyException extends Exception {</p>
<pre><code>public MyException(String message) {
    super(message);
}
</code></pre><p>}<br>Controller中增加json映射，抛出MyException异常<br>@Controller<br>public class HelloController {</p>
<pre><code>@RequestMapping(&quot;/json&quot;)
public String json() throws MyException {
    throw new MyException(&quot;发生错误2&quot;);
}
</code></pre><p>}<br>为MyException异常创建对应的处理<br>@ControllerAdvice<br>public class GlobalExceptionHandler {</p>
<pre><code>@ExceptionHandler(value = MyException.class)
@ResponseBody
public ErrorInfo&lt;String&gt; jsonErrorHandler(HttpServletRequest req, MyException e) throws Exception {
    ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;();
    r.setMessage(e.getMessage());
    r.setCode(ErrorInfo.ERROR);
    r.setData(&quot;Some Data&quot;);
    r.setUrl(req.getRequestURL().toString());
    return r;
}
</code></pre><p>}<br>启动应用，访问：<a href="http://localhost:8080/json，可以得到如下返回内容：" target="_blank" rel="external">http://localhost:8080/json，可以得到如下返回内容：</a><br>{<br>    code: 100，<br>    data: “Some Data”，<br>    message: “发生错误2”，<br>    url: “<a href="http://localhost:8080/json" target="_blank" rel="external">http://localhost:8080/json</a>“<br>}<br>至此，已完成在Spring Boot中创建统一的异常处理，实际实现还是依靠Spring MVC的注解，更多更深入的使用可参考Spring MVC的文档。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用MongoDB数据库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用MongoDB数据库/" class="article-date">
  	<time datetime="2016-06-15T09:24:10.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用MongoDB数据库/">SpringBoot中使用MongoDB数据库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用MongoDB数据库<br>2016年04月27日 标签：Spring Boot, mongodb<br>前段时间分享了关于Spring Boot中使用Redis的文章，除了Redis之后，我们在互联网产品中还经常会用到另外一款著名的NoSQL数据库MongoDB。</p>
<p>下面就来简单介绍一下MongoDB，并且通过一个例子来介绍Spring Boot中对MongoDB访问的配置和使用。</p>
<p>MongoDB简介<br>MongoDB是一个基于分布式文件存储的数据库，它是一个介于关系数据库和非关系数据库之间的产品，其主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS系统（具有丰富的功能）之间架起一座桥梁，它集两者的优势于一身。</p>
<p>MongoDB支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型，也因为他的存储格式也使得它所存储的数据在Nodejs程序应用中使用非常流畅。</p>
<p>既然称为NoSQL数据库，Mongo的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
<p>但是，MongoDB也不是万能的，同MySQL等关系型数据库相比，它们在针对不同的数据类型和事务要求上都存在自己独特的优势。在数据存储的选择中，坚持多样化原则，选择更好更经济的方式，而不是自上而下的统一化。</p>
<p>较常见的，我们可以直接用MongoDB来存储键值对类型的数据，如：验证码、Session等；由于MongoDB的横向扩展能力，也可以用来存储数据规模会在未来变的非常巨大的数据，如：日志、评论等；由于MongoDB存储数据的弱类型，也可以用来存储一些多变json数据，如：与外系统交互时经常变化的JSON报文。而对于一些对数据有复杂的高事务性要求的操作，如：账户交易等就不适合使用MongoDB来存储。</p>
<p>MongoDB官网</p>
<p>访问MongoDB<br>在Spring Boot中，对如此受欢迎的MongoDB，同样提供了自配置功能。</p>
<p>引入依赖<br>Spring Boot中可以通过在pom.xml中加入spring-boot-starter-data-mongodb引入对mongodb的访问支持依赖。它的实现依赖spring-data-mongodb。是的，您没有看错，又是spring-data的子项目，之前介绍过spring-data-jpa、spring-data-redis，对于mongodb的访问，spring-data也提供了强大的支持，下面就开始动手试试吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>快速开始使用Spring-data-mongodb<br>若MongoDB的安装配置采用默认端口，那么在自动配置的情况下，我们不需要做任何参数配置，就能马上连接上本地的MongoDB。下面直接使用spring-data-mongodb来尝试对mongodb的存取操作。（记得mongod启动您的mongodb）</p>
<p>创建要存储的User实体，包含属性：id、username、age<br>public class User {</p>
<pre><code>@Id
private Long id;

private String username;
private Integer age;

public User(Long id, String username, Integer age) {
    this.id = id;
    this.username = username;
    this.age = age;
}

// 省略getter和setter
</code></pre><p>}<br>实现User的数据访问对象：UserRepository<br>public interface UserRepository extends MongoRepository<user, long=""> {</user,></p>
<pre><code>User findByUsername(String username);
</code></pre><p>}<br>在单元测试中调用<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private UserRepository userRepository;

@Before
public void setUp() {
    userRepository.deleteAll();
}

@Test
public void test() throws Exception {

    // 创建三个User，并验证User总数
    userRepository.save(new User(1L, &quot;didi&quot;, 30));
    userRepository.save(new User(2L, &quot;mama&quot;, 40));
    userRepository.save(new User(3L, &quot;kaka&quot;, 50));
    Assert.assertEquals(3, userRepository.findAll().size());

    // 删除一个User，再验证User总数
    User u = userRepository.findOne(1L);
    userRepository.delete(u);
    Assert.assertEquals(2, userRepository.findAll().size());

    // 删除一个User，再验证User总数
    u = userRepository.findByUsername(&quot;mama&quot;);
    userRepository.delete(u);
    Assert.assertEquals(1, userRepository.findAll().size());

}
</code></pre><p>}<br>参数配置<br>通过上面的例子，我们可以轻而易举的对MongoDB进行访问，但是实战中，应用服务器与MongoDB通常不会部署于同一台设备之上，这样就无法使用自动化的本地配置来进行使用。这个时候，我们也可以方便的配置来完成支持，只需要在application.properties中加入mongodb服务端的相关配置，具体示例如下：</p>
<p>spring.data.mongodb.uri=mongodb://name:pass@localhost:27017/test<br>在尝试此配置时，记得在mongo中对test库创建具备读写权限的用户（用户名为name，密码为pass），不同版本的用户创建语句不同，注意查看文档做好准备工作</p>
<p>若使用mongodb 2.x，也可以通过如下参数配置，该方式不支持mongodb 3.x。</p>
<p>spring.data.mongodb.host=localhost spring.data.mongodb.port=27017<br>版权</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用Swagger2构建强大的RESTful-API文档" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用Swagger2构建强大的RESTful-API文档/" class="article-date">
  	<time datetime="2016-06-15T09:22:29.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用Swagger2构建强大的RESTful-API文档/">SpringBoot中使用Swagger2构建强大的RESTful-API文档</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用Swagger2构建强大的RESTful API文档<br>2016年04月18日 标签：Spring Boot, Swagger, RESTful Api<br>由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。</p>
<p>这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题：</p>
<p>由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。<br>随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。<br>为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示：</p>
<p><img src="http://blog.didispace.com/content/images/2016/04/swagger2_2.png"></p>
<p>下面来具体介绍，如果在Spring Boot中使用Swagger2。首先，我们需要一个Spring Boot实现的RESTful API工程，若您没有做过这类内容，建议先阅读 Spring Boot构建一个较为复杂的RESTful APIs和单元测试。</p>
<p>下面的内容我们会以教程样例中的Chapter3-1-1进行下面的实验（Chpater3-1-5是我们的结果工程，亦可参考）。</p>
<p>添加Swagger2依赖<br>在pom.xml中加入Swagger2的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;  </span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>创建Swagger2配置类<br>在Application.java同级创建Swagger2的配置类Swagger2。</p>
<p>@Configuration<br>@EnableSwagger2<br>public class Swagger2 {</p>
<pre><code>@Bean
public Docket createRestApi() {
    return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo())
            .select()
            .apis(RequestHandlerSelectors.basePackage(&quot;com.didispace.web&quot;))
            .paths(PathSelectors.any())
            .build();
}

private ApiInfo apiInfo() {
    return new ApiInfoBuilder()
            .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)
            .description(&quot;更多Spring Boot相关文章请关注：http://blog.didispace.com/&quot;)
            .termsOfServiceUrl(&quot;http://blog.didispace.com/&quot;)
            .contact(&quot;程序猿DD&quot;)
            .version(&quot;1.0&quot;)
            .build();
}
</code></pre><p>}<br>如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。</p>
<p>再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。</p>
<p>添加文档内容<br>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。</p>
<p>@RestController<br>@RequestMapping(value=”/users”)     // 通过这里配置使下面的映射都在/users下，可去除<br>public class UserController {</p>
<pre><code>static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;());

@ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)
@RequestMapping(value={&quot;&quot;}, method=RequestMethod.GET)
public List&lt;User&gt; getUserList() {
    List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values());
    return r;
}

@ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)
@ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
@RequestMapping(value=&quot;&quot;, method=RequestMethod.POST)
public String postUser(@RequestBody User user) {
    users.put(user.getId(), user);
    return &quot;success&quot;;
}

@ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)
@ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)
@RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.GET)
public User getUser(@PathVariable Long id) {
    return users.get(id);
}

@ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)
@ApiImplicitParams({
        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;),
        @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
})
@RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.PUT)
public String putUser(@PathVariable Long id, @RequestBody User user) {
    User u = users.get(id);
    u.setName(user.getName());
    u.setAge(user.getAge());
    users.put(id, u);
    return &quot;success&quot;;
}

@ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)
@ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)
@RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.DELETE)
public String deleteUser(@PathVariable Long id) {
    users.remove(id);
    return &quot;success&quot;;
}
</code></pre><p>}<br>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="external">http://localhost:8080/swagger-ui.html</a> 。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。</p>
<p>alt</p>
<p>API文档访问与调试<br>在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方“Try it out！”按钮，即可完成了一次请求调用！</p>
<p>此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。</p>
<p>相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用Redis数据库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用Redis数据库/" class="article-date">
  	<time datetime="2016-06-15T09:20:53.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用Redis数据库/">SpringBoot中使用Redis数据库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用Redis数据库<br>2016年04月15日 标签：Spring Boot, redis<br>Spring Boot中除了对常用的关系型数据库提供了优秀的自动化支持之外，对于很多NoSQL数据库一样提供了自动化配置的支持，包括：Redis, MongoDB, Elasticsearch, Solr和Cassandra。</p>
<p>使用Redis<br>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。</p>
<p>Redis官网<br>Redis中文社区<br>引入依赖<br>Spring Boot提供的数据访问框架Spring Data Redis基于Jedis。可以通过引入spring-boot-starter-redis来配置依赖关系。</p>
<pre><code>&lt;dependency&gt;  
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>参数配置<br>按照惯例在application.properties中加入Redis服务端的相关配置，具体说明如下：</p>
<h1 id="REDIS-RedisProperties"><a href="#REDIS-RedisProperties" class="headerlink" title="REDIS (RedisProperties)"></a>REDIS (RedisProperties)</h1><h1 id="Redis数据库索引（默认为0）"><a href="#Redis数据库索引（默认为0）" class="headerlink" title="Redis数据库索引（默认为0）"></a>Redis数据库索引（默认为0）</h1><p>spring.redis.database=0  </p>
<h1 id="Redis服务器地址"><a href="#Redis服务器地址" class="headerlink" title="Redis服务器地址"></a>Redis服务器地址</h1><p>spring.redis.host=localhost  </p>
<h1 id="Redis服务器连接端口"><a href="#Redis服务器连接端口" class="headerlink" title="Redis服务器连接端口"></a>Redis服务器连接端口</h1><p>spring.redis.port=6379  </p>
<h1 id="Redis服务器连接密码（默认为空）"><a href="#Redis服务器连接密码（默认为空）" class="headerlink" title="Redis服务器连接密码（默认为空）"></a>Redis服务器连接密码（默认为空）</h1><p>spring.redis.password=  </p>
<h1 id="连接池最大连接数（使用负值表示没有限制）"><a href="#连接池最大连接数（使用负值表示没有限制）" class="headerlink" title="连接池最大连接数（使用负值表示没有限制）"></a>连接池最大连接数（使用负值表示没有限制）</h1><p>spring.redis.pool.max-active=8  </p>
<h1 id="连接池最大阻塞等待时间（使用负值表示没有限制）"><a href="#连接池最大阻塞等待时间（使用负值表示没有限制）" class="headerlink" title="连接池最大阻塞等待时间（使用负值表示没有限制）"></a>连接池最大阻塞等待时间（使用负值表示没有限制）</h1><p>spring.redis.pool.max-wait=-1  </p>
<h1 id="连接池中的最大空闲连接"><a href="#连接池中的最大空闲连接" class="headerlink" title="连接池中的最大空闲连接"></a>连接池中的最大空闲连接</h1><p>spring.redis.pool.max-idle=8  </p>
<h1 id="连接池中的最小空闲连接"><a href="#连接池中的最小空闲连接" class="headerlink" title="连接池中的最小空闲连接"></a>连接池中的最小空闲连接</h1><p>spring.redis.pool.min-idle=0  </p>
<h1 id="连接超时时间（毫秒）"><a href="#连接超时时间（毫秒）" class="headerlink" title="连接超时时间（毫秒）"></a>连接超时时间（毫秒）</h1><p>spring.redis.timeout=0<br>其中spring.redis.database的配置通常使用0即可，Redis在配置的时候可以设置数据库数量，默认为16，可以理解为数据库的schema</p>
<p>测试访问<br>通过编写测试用例，举例说明如何访问Redis。</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private StringRedisTemplate stringRedisTemplate;

@Test
public void test() throws Exception {

    // 保存字符串
    stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);
    Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));

}
</code></pre><p>}<br>通过上面这段极为简单的测试案例演示了如何通过自动配置的StringRedisTemplate对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。如果有使用过spring-data-redis的开发者一定熟悉RedisTemplate<k, v="">接口，StringRedisTemplate就相当于RedisTemplate<string, string="">的实现。</string,></k,></p>
<p>除了String类型，实战中我们还经常会在Redis中存储对象，这时候我们就会想是否可以使用类似RedisTemplate<string, user="">来初始化并进行操作。但是Spring Boot并支持直接使用，需要我们自己实现RedisSerializer<t>接口来对传入对象进行序列化和反序列化，下面我们通过一个实例来完成对象的读写操作。</t></string,></p>
<p>创建要存储的对象：User<br>public class User implements Serializable {</p>
<pre><code>private static final long serialVersionUID = -1L;

private String username;
private Integer age;

public User(String username, Integer age) {
    this.username = username;
    this.age = age;
}

// 省略getter和setter
</code></pre><p>}<br>实现对象的序列化接口<br>public class RedisObjectSerializer implements RedisSerializer<object> {</object></p>
<p>  private Converter<object, byte[]=""> serializer = new SerializingConverter();<br>  private Converter<byte[], object=""> deserializer = new DeserializingConverter();</byte[],></object,></p>
<p>  static final byte[] EMPTY_ARRAY = new byte[0];</p>
<p>  public Object deserialize(byte[] bytes) {<br>    if (isEmpty(bytes)) {<br>      return null;<br>    }</p>
<pre><code>try {
  return deserializer.convert(bytes);
} catch (Exception ex) {
  throw new SerializationException(&quot;Cannot deserialize&quot;, ex);
}
</code></pre><p>  }</p>
<p>  public byte[] serialize(Object object) {<br>    if (object == null) {<br>      return EMPTY_ARRAY;<br>    }</p>
<pre><code>try {
  return serializer.convert(object);
} catch (Exception ex) {
  return EMPTY_ARRAY;
}
</code></pre><p>  }</p>
<p>  private boolean isEmpty(byte[] data) {<br>    return (data == null || data.length == 0);<br>  }<br>}<br>配置针对User的RedisTemplate实例<br>@Configuration<br>public class RedisConfig {</p>
<pre><code>@Bean
JedisConnectionFactory jedisConnectionFactory() {
    return new JedisConnectionFactory();
}

@Bean
public RedisTemplate&lt;String, User&gt; redisTemplate(RedisConnectionFactory factory) {
    RedisTemplate&lt;String, User&gt; template = new RedisTemplate&lt;String, User&gt;();
    template.setConnectionFactory(jedisConnectionFactory());
    template.setKeySerializer(new StringRedisSerializer());
    template.setValueSerializer(new RedisObjectSerializer());
    return template;
}
</code></pre><p>}<br>完成了配置工作后，编写测试用例实验效果<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private RedisTemplate&lt;String, User&gt; redisTemplate;

@Test
public void test() throws Exception {

    // 保存对象
    User user = new User(&quot;超人&quot;, 20);
    redisTemplate.opsForValue().set(user.getUsername(), user);

    user = new User(&quot;蝙蝠侠&quot;, 30);
    redisTemplate.opsForValue().set(user.getUsername(), user);

    user = new User(&quot;蜘蛛侠&quot;, 40);
    redisTemplate.opsForValue().set(user.getUsername(), user);

    Assert.assertEquals(20, redisTemplate.opsForValue().get(&quot;超人&quot;).getAge().longValue());
    Assert.assertEquals(30, redisTemplate.opsForValue().get(&quot;蝙蝠侠&quot;).getAge().longValue());
    Assert.assertEquals(40, redisTemplate.opsForValue().get(&quot;蜘蛛侠&quot;).getAge().longValue());

}
</code></pre><p>}<br>当然spring-data-redis中提供的数据操作远不止这些，本文仅作为在Spring Boot中使用redis时的配置参考，更多对于redis的操作使用，请参考Spring-data-redis Reference。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot日志管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot日志管理/" class="article-date">
  	<time datetime="2016-06-15T09:19:50.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot日志管理/">SpringBoot日志管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot日志管理<br>2016年04月13日 标签：Spring Boot<br>Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。</p>
<p>格式化日志<br>默认的日志输出如下：</p>
<p>2016-04-13 08:23:50.120  INFO 37397 — [           main] org.hibernate.Version                    : HHH000412: Hibernate Core {4.3.11.Final}<br>输出内容元素具体如下：</p>
<p>时间日期 — 精确到毫秒<br>日志级别 — ERROR, WARN, INFO, DEBUG or TRACE<br>进程ID<br>分隔符 — — 标识实际日志的开始<br>线程名 — 方括号括起来（可能会截断控制台输出）<br>Logger名 — 通常使用源代码的类名<br>日志内容<br>控制台输出<br>在Spring Boot中默认配置了ERROR、WARN和INFO级别的日志输出到控制台。</p>
<p>我们可以通过两种方式切换至DEBUG级别：</p>
<p>在运行命令后加入–debug标志，如：$ java -jar myapp.jar –debug<br>在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。<br>多彩输出<br>如果你的终端支持ANSI，设置彩色输出会让日志更具可读性。通过在application.properties中设置spring.output.ansi.enabled参数来支持。</p>
<p>NEVER：禁用ANSI-colored输出（默认项）<br>DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（推荐项）<br>ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用<br>文件输出<br>Spring Boot默认配置只会输出到控制台，并不会记录到文件中，但是我们通常生产环境使用时都需要以文件方式记录。</p>
<p>若要增加文件输出，需要在application.properties中配置logging.file或logging.path属性。</p>
<p>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log<br>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log</p>
<ul>
<li>日志文件会在10Mb大小的时候被截断，产生新的日志文件，默认级别为：ERROR、WARN、INFO *</li>
</ul>
<p>级别控制<br>在Spring Boot中只需要在application.properties中进行配置完成日志记录的级别控制。</p>
<p>配置格式：logging.level.*=LEVEL</p>
<p>logging.level：日志级别控制前缀，*为包名或Logger名<br>LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF<br>举例：</p>
<p>logging.level.com.didispace=DEBUG：com.didispace包下所有class以DEBUG级别输出<br>logging.level.root=WARN：root日志以WARN级别输出<br>自定义日志配置<br>由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。</p>
<p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p>
<p>Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy<br>Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml<br>Log4j2：log4j2-spring.xml, log4j2.xml<br>JDK (Java Util Logging)：logging.properties<br>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml）</p>
<p>自定义输出格式<br>在Spring Boot中可以通过在application.properties配置如下参数控制输出格式：</p>
<p>logging.pattern.console：定义输出到控制台的样式（不支持JDK Logger）<br>logging.pattern.file：定义输出到文件的样式（不支持JDK Logger）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-springBoot多数据源配置与使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/springBoot多数据源配置与使用/" class="article-date">
  	<time datetime="2016-06-15T09:18:31.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/springBoot多数据源配置与使用/">springBoot多数据源配置与使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot多数据源配置与使用<br>2016年03月28日 标签：Spring Boot<br>之前在介绍使用JdbcTemplate和Spring-data-jpa时，都使用了单数据源。在单数据源的情况下，Spring Boot的配置非常简单，只需要在application.properties文件中配置连接参数即可。但是往往随着业务量发展，我们通常会进行数据库拆分或是引入其他数据库，从而我们需要配置多个数据源，下面基于之前的JdbcTemplate和Spring-data-jpa例子分别介绍两种多数据源的配置方式。</p>
<p>多数据源配置<br>创建一个Spring配置类，定义两个DataSource用来读取application.properties中的不同配置。如下例子中，主数据源配置为spring.datasource.primary开头的配置，第二数据源配置为spring.datasource.secondary开头的配置。</p>
<p>@Configuration<br>public class DataSourceConfig {</p>
<pre><code>@Bean(name = &quot;primaryDataSource&quot;)
@Qualifier(&quot;primaryDataSource&quot;)
@ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)
public DataSource primaryDataSource() {
    return DataSourceBuilder.create().build();
}

@Bean(name = &quot;secondaryDataSource&quot;)
@Qualifier(&quot;secondaryDataSource&quot;)
@Primary
@ConfigurationProperties(prefix=&quot;spring.datasource.secondary&quot;)
public DataSource secondaryDataSource() {
    return DataSourceBuilder.create().build();
}
</code></pre><p>}<br>对应的application.properties配置如下：</p>
<p>spring.datasource.primary.url=jdbc:mysql://localhost:3306/test1<br>spring.datasource.primary.username=root<br>spring.datasource.primary.password=root<br>spring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver</p>
<p>spring.datasource.secondary.url=jdbc:mysql://localhost:3306/test2<br>spring.datasource.secondary.username=root<br>spring.datasource.secondary.password=root<br>spring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driver<br>JdbcTemplate支持<br>对JdbcTemplate的支持比较简单，只需要为其注入对应的datasource即可，如下例子，在创建JdbcTemplate的时候分别注入名为primaryDataSource和secondaryDataSource的数据源来区分不同的JdbcTemplate。</p>
<pre><code>@Bean(name = &quot;primaryJdbcTemplate&quot;)
public JdbcTemplate primaryJdbcTemplate(
        @Qualifier(&quot;primaryDataSource&quot;) DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}

@Bean(name = &quot;secondaryJdbcTemplate&quot;)
public JdbcTemplate secondaryJdbcTemplate(
        @Qualifier(&quot;secondaryDataSource&quot;) DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}
</code></pre><p>接下来通过测试用例来演示如何使用这两个针对不同数据源的JdbcTemplate。</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
@Qualifier(&quot;primaryJdbcTemplate&quot;)
protected JdbcTemplate jdbcTemplate1;

@Autowired
@Qualifier(&quot;secondaryJdbcTemplate&quot;)
protected JdbcTemplate jdbcTemplate2;

@Before
public void setUp() {
    jdbcTemplate1.update(&quot;DELETE  FROM  USER &quot;);
    jdbcTemplate2.update(&quot;DELETE  FROM  USER &quot;);
}

@Test
public void test() throws Exception {

    // 往第一个数据源中插入两条数据
    jdbcTemplate1.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 1, &quot;aaa&quot;, 20);
    jdbcTemplate1.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 2, &quot;bbb&quot;, 30);

    // 往第二个数据源中插入一条数据，若插入的是第一个数据源，则会主键冲突报错
    jdbcTemplate2.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 1, &quot;aaa&quot;, 20);

    // 查一下第一个数据源中是否有两条数据，验证插入是否成功
    Assert.assertEquals(&quot;2&quot;, jdbcTemplate1.queryForObject(&quot;select count(1) from user&quot;, String.class));

    // 查一下第一个数据源中是否有两条数据，验证插入是否成功
    Assert.assertEquals(&quot;1&quot;, jdbcTemplate2.queryForObject(&quot;select count(1) from user&quot;, String.class));

}
</code></pre><p>}<br>完整示例:Chapter3-2-3</p>
<p>Spring-data-jpa支持<br>对于数据源的配置可以沿用上例中DataSourceConfig的实现。</p>
<p>新增对第一数据源的JPA配置，注意两处注释的地方，用于指定数据源对应的Entity实体和Repository定义位置，用@Primary区分主数据源。</p>
<p>@Configuration<br>@EnableTransactionManagement<br>@EnableJpaRepositories(<br>        entityManagerFactoryRef=”entityManagerFactoryPrimary”,<br>        transactionManagerRef=”transactionManagerPrimary”,<br>        basePackages= { “com.didispace.domain.p” }) //设置Repository所在位置<br>public class PrimaryConfig {</p>
<pre><code>@Autowired @Qualifier(&quot;primaryDataSource&quot;)
private DataSource primaryDataSource;

@Primary
@Bean(name = &quot;entityManagerPrimary&quot;)
public EntityManager entityManager(EntityManagerFactoryBuilder builder) {
    return entityManagerFactoryPrimary(builder).getObject().createEntityManager();
}

@Primary
@Bean(name = &quot;entityManagerFactoryPrimary&quot;)
public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) {
    return builder
            .dataSource(primaryDataSource)
            .properties(getVendorProperties(primaryDataSource))
            .packages(&quot;com.didispace.domain.p&quot;) //设置实体类所在位置
            .persistenceUnit(&quot;primaryPersistenceUnit&quot;)
            .build();
}

@Autowired
private JpaProperties jpaProperties;

private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {
    return jpaProperties.getHibernateProperties(dataSource);
}

@Primary
@Bean(name = &quot;transactionManagerPrimary&quot;)
public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) {
    return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());
}
</code></pre><p>}<br>新增对第二数据源的JPA配置，内容与第一数据源类似，具体如下：</p>
<p>@Configuration<br>@EnableTransactionManagement<br>@EnableJpaRepositories(<br>        entityManagerFactoryRef=”entityManagerFactorySecondary”,<br>        transactionManagerRef=”transactionManagerSecondary”,<br>        basePackages= { “com.didispace.domain.s” }) //设置Repository所在位置<br>public class SecondaryConfig {</p>
<pre><code>@Autowired @Qualifier(&quot;secondaryDataSource&quot;)
private DataSource secondaryDataSource;

@Bean(name = &quot;entityManagerSecondary&quot;)
public EntityManager entityManager(EntityManagerFactoryBuilder builder) {
    return entityManagerFactorySecondary(builder).getObject().createEntityManager();
}

@Bean(name = &quot;entityManagerFactorySecondary&quot;)
public LocalContainerEntityManagerFactoryBean entityManagerFactorySecondary (EntityManagerFactoryBuilder builder) {
    return builder
            .dataSource(secondaryDataSource)
            .properties(getVendorProperties(secondaryDataSource))
            .packages(&quot;com.didispace.domain.s&quot;) //设置实体类所在位置
            .persistenceUnit(&quot;secondaryPersistenceUnit&quot;)
            .build();
}

@Autowired
private JpaProperties jpaProperties;

private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {
    return jpaProperties.getHibernateProperties(dataSource);
}

@Bean(name = &quot;transactionManagerSecondary&quot;)
PlatformTransactionManager transactionManagerSecondary(EntityManagerFactoryBuilder builder) {
    return new JpaTransactionManager(entityManagerFactorySecondary(builder).getObject());
}
</code></pre><p>}<br>完成了以上配置之后，主数据源的实体和数据访问对象位于：com.didispace.domain.p，次数据源的实体和数据访问接口位于：com.didispace.domain.s。</p>
<p>分别在这两个package下创建各自的实体和数据访问接口</p>
<p>主数据源下，创建User实体和对应的Repository接口<br>@Entity<br>public class User {</p>
<pre><code>@Id
@GeneratedValue
private Long id;

@Column(nullable = false)
private String name;

@Column(nullable = false)
private Integer age;

public User(){}

public User(String name, Integer age) {
    this.name = name;
    this.age = age;
}

// 省略getter、setter
</code></pre><p>}<br>public interface UserRepository extends JpaRepository<user, long=""> {</user,></p>
<p>}<br>从数据源下，创建Message实体和对应的Repository接口<br>@Entity<br>public class Message {</p>
<pre><code>@Id
@GeneratedValue
private Long id;

@Column(nullable = false)
private String name;

@Column(nullable = false)
private String content;

public Message(){}

public Message(String name, String content) {
    this.name = name;
    this.content = content;
}

// 省略getter、setter
</code></pre><p>}<br>public interface MessageRepository extends JpaRepository<message, long=""> {</message,></p>
<p>}<br>接下来通过测试用例来验证使用这两个针对不同数据源的配置进行数据操作。</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private UserRepository userRepository;
@Autowired
private MessageRepository messageRepository;

@Test
public void test() throws Exception {

    userRepository.save(new User(&quot;aaa&quot;, 10));
    userRepository.save(new User(&quot;bbb&quot;, 20));
    userRepository.save(new User(&quot;ccc&quot;, 30));
    userRepository.save(new User(&quot;ddd&quot;, 40));
    userRepository.save(new User(&quot;eee&quot;, 50));

    Assert.assertEquals(5, userRepository.findAll().size());

    messageRepository.save(new Message(&quot;o1&quot;, &quot;aaaaaaaaaa&quot;));
    messageRepository.save(new Message(&quot;o2&quot;, &quot;bbbbbbbbbb&quot;));
    messageRepository.save(new Message(&quot;o3&quot;, &quot;cccccccccc&quot;));

    Assert.assertEquals(3, messageRepository.findAll().size());

}
</code></pre><p>}<br>完整示例:Chapter3-2-4</p>
<p>版权申明：署名-非商业性使用-禁止演绎 3.0 (CC BY-NC-ND 3.0)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用Spring-data-jpa让数据访问更简单更优雅" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用Spring-data-jpa让数据访问更简单更优雅/" class="article-date">
  	<time datetime="2016-06-15T09:17:16.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用Spring-data-jpa让数据访问更简单更优雅/">SpringBoot中使用Spring-data-jpa让数据访问更简单更优雅</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用Spring-data-jpa让数据访问更简单、更优雅<br>2016年03月24日 标签：Spring Boot<br>在上一篇Spring中使用JdbcTemplate访问数据库 中介绍了一种基本的数据访问方式，结合构建RESTful API和使用Thymeleaf模板引擎渲染Web视图的内容就已经可以完成App服务端和Web站点的开发任务了。</p>
<p>然而，在实际开发过程中，对数据库的操作无非就“增删改查”。就最为普遍的单表操作而言，除了表和字段不同外，语句都是类似的，开发人员需要写大量类似而枯燥的语句来完成业务逻辑。</p>
<p>为了解决这些大量枯燥的数据操作语句，我们第一个想到的是使用ORM框架，比如：Hibernate。通过整合Hibernate之后，我们以操作Java实体的方式最终将数据改变映射到数据库表中。</p>
<p>为了解决抽象各个Java实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板Dao来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板Dao的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆Dao的接口和实现。</p>
<p>由于模板Dao的实现，使得这些具体实体的Dao层已经变的非常“薄”，有一些具体实体的Dao实现可能完全就是对模板Dao的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring-data-jpa的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。比如，下面的例子：</p>
<p>public interface UserRepository extends JpaRepository<user, long=""> {</user,></p>
<pre><code>User findByName(String name);

@Query(&quot;from User u where u.name=:name&quot;)
User findUser(@Param(&quot;name&quot;) String name);
</code></pre><p>}<br>我们只需要通过编写一个继承自JpaRepository的接口就能完成数据访问，下面以一个具体实例来体验Spring-data-jpa给我们带来的强大功能。</p>
<p>使用示例<br>由于Spring-data-jpa依赖于Hibernate。如果您对Hibernate有一定了解，下面内容可以毫不费力的看懂并上手使用Spring-data-jpa。如果您还是Hibernate新手，您可以先按如下方式入门，再建议回头学习一下Hibernate以帮助这部分的理解和进一步使用。</p>
<p>工程配置<br>在pom.xml中添加相关依赖，加入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>在application.xml中配置：数据库连接信息（如使用嵌入式数据库则不需要）、自动创建表结构的设置，例如使用mysql的情况如下：</p>
<p>spring.datasource.url=jdbc:mysql://localhost:3306/test<br>spring.datasource.username=root<br>spring.datasource.password=root<br>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</p>
<p>spring.jpa.properties.hibernate.hbm2ddl.auto=create-drop<br>spring.jpa.properties.hibernate.hbm2ddl.auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：</p>
<p>create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。<br>create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。<br>update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。<br>validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。<br>至此已经完成基础配置，如果您有在Spring下整合使用过它的话，相信你已经感受到Spring Boot的便利之处：JPA的传统配置在persistence.xml文件中，但是这里我们不需要。当然，最好在构建项目时候按照之前提过的最佳实践的工程结构来组织，这样以确保各种配置都能被框架扫描到。</p>
<p>创建实体<br>创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。</p>
<p>@Entity<br>public class User {</p>
<pre><code>@Id
@GeneratedValue
private Long id;

@Column(nullable = false)
private String name;

@Column(nullable = false)
private Integer age;

// 省略构造函数

// 省略getter和setter
</code></pre><p>}<br>创建数据访问接口<br>下面针对User实体创建对应的Repository接口实现对该实体的数据访问，如下代码：</p>
<p>public interface UserRepository extends JpaRepository<user, long=""> {</user,></p>
<pre><code>User findByName(String name);

User findByNameAndAge(String name, Integer age);

@Query(&quot;from User u where u.name=:name&quot;)
User findUser(@Param(&quot;name&quot;) String name);
</code></pre><p>}<br>在Spring-data-jpa中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类，直接减少了我们的文件清单。</p>
<p>下面对上面的UserRepository做一些解释，该接口继承自JpaRepository，通过查看JpaRepository接口的API文档，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。</p>
<p>在我们实际开发中，JpaRepository接口定义的接口往往还不够或者性能不够优化，我们需要进一步实现更复杂一些的查询或操作。由于本文重点在spring boot中整合spring-data-jpa，在这里先抛砖引玉简单介绍一下spring-data-jpa中让我们兴奋的功能，后续再单独开篇讲一下spring-data-jpa中的常见使用。</p>
<p>在上例中，我们可以看到下面两个函数：</p>
<p>User findByName(String name)<br>User findByNameAndAge(String name, Integer age)<br>它们分别实现了按name查询User实体和按name和age查询User实体，可以看到我们这里没有任何类SQL语句就完成了两个条件查询方法。这就是Spring-data-jpa的一大特性：通过解析方法名创建查询。</p>
<p>除了通过解析方法名来创建查询外，它也提供通过使用@Query 注解来创建查询，您只需要编写JPQL语句，并通过类似“:name”来映射@Param指定的参数，就像例子中的第三个findUser函数一样。</p>
<p>Spring-data-jpa的能力远不止本文提到的这些，由于本文主要以整合介绍为主，对于Spring-data-jpa的使用只是介绍了常见的使用方式。诸如@Modifying操作、分页排序、原生SQL支持以及与Spring MVC的结合使用等等内容就不在本文中详细展开，这里先挖个坑，后续再补文章填坑，如您对这些感兴趣可以关注我博客或简书，同样欢迎大家留言交流想法。</p>
<p>单元测试<br>在完成了上面的数据访问接口之后，按照惯例就是编写对应的单元测试来验证编写的内容是否正确。这里就不多做介绍，主要通过数据操作和查询来反复验证操作的正确性。</p>
<p>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private UserRepository userRepository;

@Test
public void test() throws Exception {

    // 创建10条记录
    userRepository.save(new User(&quot;AAA&quot;, 10));
    userRepository.save(new User(&quot;BBB&quot;, 20));
    userRepository.save(new User(&quot;CCC&quot;, 30));
    userRepository.save(new User(&quot;DDD&quot;, 40));
    userRepository.save(new User(&quot;EEE&quot;, 50));
    userRepository.save(new User(&quot;FFF&quot;, 60));
    userRepository.save(new User(&quot;GGG&quot;, 70));
    userRepository.save(new User(&quot;HHH&quot;, 80));
    userRepository.save(new User(&quot;III&quot;, 90));
    userRepository.save(new User(&quot;JJJ&quot;, 100));

    // 测试findAll, 查询所有记录
    Assert.assertEquals(10, userRepository.findAll().size());

    // 测试findByName, 查询姓名为FFF的User
    Assert.assertEquals(60, userRepository.findByName(&quot;FFF&quot;).getAge().longValue());

    // 测试findUser, 查询姓名为FFF的User
    Assert.assertEquals(60, userRepository.findUser(&quot;FFF&quot;).getAge().longValue());

    // 测试findByNameAndAge, 查询姓名为FFF并且年龄为60的User
    Assert.assertEquals(&quot;FFF&quot;, userRepository.findByNameAndAge(&quot;FFF&quot;, 60).getName());

    // 测试删除姓名为AAA的User
    userRepository.delete(userRepository.findByName(&quot;AAA&quot;));

    // 测试findAll, 查询所有记录, 验证上面的删除是否成功
    Assert.assertEquals(9, userRepository.findAll().size());

}
</code></pre><p>}<br>完整示例</p>
<p>版权申明：署名-非商业性使用-禁止演绎 3.0 (CC BY-NC-ND 3.0)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SpringBoot中使用JdbcTemplate访问数据库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/SpringBoot中使用JdbcTemplate访问数据库/" class="article-date">
  	<time datetime="2016-06-15T09:15:58.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/SpringBoot中使用JdbcTemplate访问数据库/">SpringBoot中使用JdbcTemplate访问数据库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot中使用JdbcTemplate访问数据库<br>2016年03月17日 标签：Spring Boot<br>之前介绍了很多Web层的例子，包括构建RESTful API、使用Thymeleaf模板引擎渲染Web视图，但是这些内容还不足以构建一个动态的应用。通常我们做App也好，做Web应用也好，都需要内容，而内容通常存储于各种类型的数据库，服务端在接收到访问请求之后需要访问数据库获取并处理成展现给用户使用的数据形式。</p>
<p>本文介绍在Spring Boot基础下配置数据源和通过JdbcTemplate编写数据访问的示例。</p>
<p>数据源配置<br>在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。</p>
<p>首先，为了连接数据库需要引入jdbc支持，在pom.xml中引入如下配置：<br>``</p>
<p><dependency><br>    <groupid>org.springframework.boot</groupid><br>    <artifactid>spring-boot-starter-jdbc</artifactid><br></dependency><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">嵌入式数据库支持</span><br><span class="line">嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot提供自动配置的嵌入式数据库有H2、HSQL、Derby，你不需要提供任何连接配置就能使用。</span><br><span class="line"></span><br><span class="line">比如，我们可以在pom.xml中引入如下配置使用HSQL</span><br></pre></td></tr></table></figure></p>
<p><dependency><br>    <groupid>org.hsqldb</groupid><br>    <artifactid>hsqldb</artifactid><br>    <scope>runtime</scope><br></dependency><br>连接生产数据源<br>以MySQL数据库为例，先引入MySQL连接的依赖包，在pom.xml中加入：</p>
<p><dependency><br>    <groupid>mysql</groupid><br>    <artifactid>mysql-connector-java</artifactid><br>    <version>5.1.21</version><br></dependency><br>```<br>在src/main/resources/application.properties中配置数据源信息</p>
<p>spring.datasource.url=jdbc:mysql://localhost:3306/test<br>spring.datasource.username=dbuser<br>spring.datasource.password=dbpass<br>spring.datasource.driver-class-name=com.mysql.jdbc.Driver<br>连接JNDI数据源<br>当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。</p>
<p>spring.datasource.jndi-name=java:jboss/datasources/customers<br>使用JdbcTemplate操作数据库<br>Spring的JdbcTemplate是自动配置的，你可以直接使用@Autowired来注入到你自己的bean中来使用。</p>
<p>举例：我们在创建User表，包含属性name、age，下面来编写数据访问对象和单元测试用例。</p>
<p>定义包含有插入、删除、查询的抽象接口UserService<br>public interface UserService {</p>
<pre><code>/**
 * 新增一个用户
 * @param name
 * @param age
 */
void create(String name, Integer age);

/**
 * 根据name删除一个用户高
 * @param name
 */
void deleteByName(String name);

/**
 * 获取用户总量
 */
Integer getAllUsers();

/**
 * 删除所有用户
 */
void deleteAllUsers();
</code></pre><p>}<br>通过JdbcTemplate实现UserService中定义的数据访问操作<br>@Service<br>public class UserServiceImpl implements UserService {</p>
<pre><code>@Autowired
private JdbcTemplate jdbcTemplate;

@Override
public void create(String name, Integer age) {
    jdbcTemplate.update(&quot;insert into USER(NAME, AGE) values(?, ?)&quot;, name, age);
}

@Override
public void deleteByName(String name) {
    jdbcTemplate.update(&quot;delete from USER where NAME = ?&quot;, name);
}

@Override
public Integer getAllUsers() {
    return jdbcTemplate.queryForObject(&quot;select count(1) from USER&quot;, Integer.class);
}

@Override
public void deleteAllUsers() {
    jdbcTemplate.update(&quot;delete from USER&quot;);
}
</code></pre><p>}<br>创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@SpringApplicationConfiguration(Application.class)<br>public class ApplicationTests {</p>
<pre><code>@Autowired
private UserService userSerivce;

@Before
public void setUp() {
    // 准备，清空user表
    userSerivce.deleteAllUsers();
}

@Test
public void test() throws Exception {
    // 插入5个用户
    userSerivce.create(&quot;a&quot;, 1);
    userSerivce.create(&quot;b&quot;, 2);
    userSerivce.create(&quot;c&quot;, 3);
    userSerivce.create(&quot;d&quot;, 4);
    userSerivce.create(&quot;e&quot;, 5);

    // 查数据库，应该有5个用户
    Assert.assertEquals(5, userSerivce.getAllUsers().intValue());

    // 删除两个用户
    userSerivce.deleteByName(&quot;a&quot;);
    userSerivce.deleteByName(&quot;e&quot;);

    // 查数据库，应该有5个用户
    Assert.assertEquals(3, userSerivce.getAllUsers().intValue());

}
</code></pre><p>}<br>上面介绍的JdbcTemplate只是最基本的几个操作，更多其他数据访问操作的使用请参考：JdbcTemplate API</p>
<p>通过上面这个简单的例子，我们可以看到在Spring Boot下访问数据库的配置依然秉承了框架的初衷：简单。我们只需要在pom.xml中加入数据库依赖，再到application.properties中配置连接信息，不需要像Spring应用中创建JdbcTemplate的Bean，就可以直接在自己的对象中注入使用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 菜菜
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>